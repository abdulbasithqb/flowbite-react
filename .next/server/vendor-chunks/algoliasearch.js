"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/algoliasearch";
exports.ids = ["vendor-chunks/algoliasearch"];
exports.modules = {

/***/ "(ssr)/./node_modules/algoliasearch/dist/algoliasearch-lite.esm.browser.js":
/*!***************************************************************************!*\
  !*** ./node_modules/algoliasearch/dist/algoliasearch-lite.esm.browser.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction createBrowserLocalStorageCache(options) {\n    const namespaceKey = `algoliasearch-client-js-${options.key}`;\n    // eslint-disable-next-line functional/no-let\n    let storage;\n    const getStorage = ()=>{\n        if (storage === undefined) {\n            storage = options.localStorage || window.localStorage;\n        }\n        return storage;\n    };\n    const getNamespace = ()=>{\n        return JSON.parse(getStorage().getItem(namespaceKey) || \"{}\");\n    };\n    const setNamespace = (namespace)=>{\n        getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n    };\n    const removeOutdatedCacheItems = ()=>{\n        const timeToLive = options.timeToLive ? options.timeToLive * 1000 : null;\n        const namespace = getNamespace();\n        const filteredNamespaceWithoutOldFormattedCacheItems = Object.fromEntries(Object.entries(namespace).filter(([, cacheItem])=>{\n            return cacheItem.timestamp !== undefined;\n        }));\n        setNamespace(filteredNamespaceWithoutOldFormattedCacheItems);\n        if (!timeToLive) return;\n        const filteredNamespaceWithoutExpiredItems = Object.fromEntries(Object.entries(filteredNamespaceWithoutOldFormattedCacheItems).filter(([, cacheItem])=>{\n            const currentTimestamp = new Date().getTime();\n            const isExpired = cacheItem.timestamp + timeToLive < currentTimestamp;\n            return !isExpired;\n        }));\n        setNamespace(filteredNamespaceWithoutExpiredItems);\n    };\n    return {\n        get (key, defaultValue, events = {\n            miss: ()=>Promise.resolve()\n        }) {\n            return Promise.resolve().then(()=>{\n                removeOutdatedCacheItems();\n                const keyAsString = JSON.stringify(key);\n                return getNamespace()[keyAsString];\n            }).then((value)=>{\n                return Promise.all([\n                    value ? value.value : defaultValue(),\n                    value !== undefined\n                ]);\n            }).then(([value, exists])=>{\n                return Promise.all([\n                    value,\n                    exists || events.miss(value)\n                ]);\n            }).then(([value])=>value);\n        },\n        set (key, value) {\n            return Promise.resolve().then(()=>{\n                const namespace = getNamespace();\n                // eslint-disable-next-line functional/immutable-data\n                namespace[JSON.stringify(key)] = {\n                    timestamp: new Date().getTime(),\n                    value\n                };\n                getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n                return value;\n            });\n        },\n        delete (key) {\n            return Promise.resolve().then(()=>{\n                const namespace = getNamespace();\n                // eslint-disable-next-line functional/immutable-data\n                delete namespace[JSON.stringify(key)];\n                getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n            });\n        },\n        clear () {\n            return Promise.resolve().then(()=>{\n                getStorage().removeItem(namespaceKey);\n            });\n        }\n    };\n}\n// @todo Add logger on options to debug when caches go wrong.\nfunction createFallbackableCache(options) {\n    const caches = [\n        ...options.caches\n    ];\n    const current = caches.shift(); // eslint-disable-line functional/immutable-data\n    if (current === undefined) {\n        return createNullCache();\n    }\n    return {\n        get (key, defaultValue, events = {\n            miss: ()=>Promise.resolve()\n        }) {\n            return current.get(key, defaultValue, events).catch(()=>{\n                return createFallbackableCache({\n                    caches\n                }).get(key, defaultValue, events);\n            });\n        },\n        set (key, value) {\n            return current.set(key, value).catch(()=>{\n                return createFallbackableCache({\n                    caches\n                }).set(key, value);\n            });\n        },\n        delete (key) {\n            return current.delete(key).catch(()=>{\n                return createFallbackableCache({\n                    caches\n                }).delete(key);\n            });\n        },\n        clear () {\n            return current.clear().catch(()=>{\n                return createFallbackableCache({\n                    caches\n                }).clear();\n            });\n        }\n    };\n}\nfunction createNullCache() {\n    return {\n        get (_key, defaultValue, events = {\n            miss: ()=>Promise.resolve()\n        }) {\n            const value = defaultValue();\n            return value.then((result)=>Promise.all([\n                    result,\n                    events.miss(result)\n                ])).then(([result])=>result);\n        },\n        set (_key, value) {\n            return Promise.resolve(value);\n        },\n        delete (_key) {\n            return Promise.resolve();\n        },\n        clear () {\n            return Promise.resolve();\n        }\n    };\n}\nfunction createInMemoryCache(options = {\n    serializable: true\n}) {\n    // eslint-disable-next-line functional/no-let\n    let cache = {};\n    return {\n        get (key, defaultValue, events = {\n            miss: ()=>Promise.resolve()\n        }) {\n            const keyAsString = JSON.stringify(key);\n            if (keyAsString in cache) {\n                return Promise.resolve(options.serializable ? JSON.parse(cache[keyAsString]) : cache[keyAsString]);\n            }\n            const promise = defaultValue();\n            const miss = events && events.miss || (()=>Promise.resolve());\n            return promise.then((value)=>miss(value)).then(()=>promise);\n        },\n        set (key, value) {\n            // eslint-disable-next-line functional/immutable-data\n            cache[JSON.stringify(key)] = options.serializable ? JSON.stringify(value) : value;\n            return Promise.resolve(value);\n        },\n        delete (key) {\n            // eslint-disable-next-line functional/immutable-data\n            delete cache[JSON.stringify(key)];\n            return Promise.resolve();\n        },\n        clear () {\n            cache = {};\n            return Promise.resolve();\n        }\n    };\n}\nfunction createAuth(authMode, appId, apiKey) {\n    const credentials = {\n        \"x-algolia-api-key\": apiKey,\n        \"x-algolia-application-id\": appId\n    };\n    return {\n        headers () {\n            return authMode === AuthMode.WithinHeaders ? credentials : {};\n        },\n        queryParameters () {\n            return authMode === AuthMode.WithinQueryParameters ? credentials : {};\n        }\n    };\n}\n// eslint-disable-next-line functional/prefer-readonly-type\nfunction shuffle(array) {\n    let c = array.length - 1; // eslint-disable-line functional/no-let\n    // eslint-disable-next-line functional/no-loop-statement\n    for(c; c > 0; c--){\n        const b = Math.floor(Math.random() * (c + 1));\n        const a = array[c];\n        array[c] = array[b]; // eslint-disable-line functional/immutable-data, no-param-reassign\n        array[b] = a; // eslint-disable-line functional/immutable-data, no-param-reassign\n    }\n    return array;\n}\nfunction addMethods(base, methods) {\n    if (!methods) {\n        return base;\n    }\n    Object.keys(methods).forEach((key)=>{\n        // eslint-disable-next-line functional/immutable-data, no-param-reassign\n        base[key] = methods[key](base);\n    });\n    return base;\n}\nfunction encode(format, ...args) {\n    // eslint-disable-next-line functional/no-let\n    let i = 0;\n    return format.replace(/%s/g, ()=>encodeURIComponent(args[i++]));\n}\nconst version = \"4.22.0\";\nconst AuthMode = {\n    /**\r\n     * If auth credentials should be in query parameters.\r\n     */ WithinQueryParameters: 0,\n    /**\r\n     * If auth credentials should be in headers.\r\n     */ WithinHeaders: 1\n};\nfunction createMappedRequestOptions(requestOptions, timeout) {\n    const options = requestOptions || {};\n    const data = options.data || {};\n    Object.keys(options).forEach((key)=>{\n        if ([\n            \"timeout\",\n            \"headers\",\n            \"queryParameters\",\n            \"data\",\n            \"cacheable\"\n        ].indexOf(key) === -1) {\n            data[key] = options[key]; // eslint-disable-line functional/immutable-data\n        }\n    });\n    return {\n        data: Object.entries(data).length > 0 ? data : undefined,\n        timeout: options.timeout || timeout,\n        headers: options.headers || {},\n        queryParameters: options.queryParameters || {},\n        cacheable: options.cacheable\n    };\n}\nconst CallEnum = {\n    /**\r\n     * If the host is read only.\r\n     */ Read: 1,\n    /**\r\n     * If the host is write only.\r\n     */ Write: 2,\n    /**\r\n     * If the host is both read and write.\r\n     */ Any: 3\n};\nconst HostStatusEnum = {\n    Up: 1,\n    Down: 2,\n    Timeouted: 3\n};\n// By default, API Clients at Algolia have expiration delay\n// of 5 mins. In the JavaScript client, we have 2 mins.\nconst EXPIRATION_DELAY = 2 * 60 * 1000;\nfunction createStatefulHost(host, status = HostStatusEnum.Up) {\n    return {\n        ...host,\n        status,\n        lastUpdate: Date.now()\n    };\n}\nfunction isStatefulHostUp(host) {\n    return host.status === HostStatusEnum.Up || Date.now() - host.lastUpdate > EXPIRATION_DELAY;\n}\nfunction isStatefulHostTimeouted(host) {\n    return host.status === HostStatusEnum.Timeouted && Date.now() - host.lastUpdate <= EXPIRATION_DELAY;\n}\nfunction createStatelessHost(options) {\n    if (typeof options === \"string\") {\n        return {\n            protocol: \"https\",\n            url: options,\n            accept: CallEnum.Any\n        };\n    }\n    return {\n        protocol: options.protocol || \"https\",\n        url: options.url,\n        accept: options.accept || CallEnum.Any\n    };\n}\nconst MethodEnum = {\n    Delete: \"DELETE\",\n    Get: \"GET\",\n    Post: \"POST\",\n    Put: \"PUT\"\n};\nfunction createRetryableOptions(hostsCache, statelessHosts) {\n    return Promise.all(statelessHosts.map((statelessHost)=>{\n        return hostsCache.get(statelessHost, ()=>{\n            return Promise.resolve(createStatefulHost(statelessHost));\n        });\n    })).then((statefulHosts)=>{\n        const hostsUp = statefulHosts.filter((host)=>isStatefulHostUp(host));\n        const hostsTimeouted = statefulHosts.filter((host)=>isStatefulHostTimeouted(host));\n        /**\r\n         * Note, we put the hosts that previously timeouted on the end of the list.\r\n         */ const hostsAvailable = [\n            ...hostsUp,\n            ...hostsTimeouted\n        ];\n        const statelessHostsAvailable = hostsAvailable.length > 0 ? hostsAvailable.map((host)=>createStatelessHost(host)) : statelessHosts;\n        return {\n            getTimeout (timeoutsCount, baseTimeout) {\n                /**\r\n                 * Imagine that you have 4 hosts, if timeouts will increase\r\n                 * on the following way: 1 (timeouted) > 4 (timeouted) > 5 (200)\r\n                 *\r\n                 * Note that, the very next request, we start from the previous timeout\r\n                 *\r\n                 *  5 (timeouted) > 6 (timeouted) > 7 ...\r\n                 *\r\n                 * This strategy may need to be reviewed, but is the strategy on the our\r\n                 * current v3 version.\r\n                 */ const timeoutMultiplier = hostsTimeouted.length === 0 && timeoutsCount === 0 ? 1 : hostsTimeouted.length + 3 + timeoutsCount;\n                return timeoutMultiplier * baseTimeout;\n            },\n            statelessHosts: statelessHostsAvailable\n        };\n    });\n}\nconst isNetworkError = ({ isTimedOut, status })=>{\n    return !isTimedOut && ~~status === 0;\n};\nconst isRetryable = (response)=>{\n    const status = response.status;\n    const isTimedOut = response.isTimedOut;\n    return isTimedOut || isNetworkError(response) || ~~(status / 100) !== 2 && ~~(status / 100) !== 4;\n};\nconst isSuccess = ({ status })=>{\n    return ~~(status / 100) === 2;\n};\nconst retryDecision = (response, outcomes)=>{\n    if (isRetryable(response)) {\n        return outcomes.onRetry(response);\n    }\n    if (isSuccess(response)) {\n        return outcomes.onSuccess(response);\n    }\n    return outcomes.onFail(response);\n};\nfunction retryableRequest(transporter, statelessHosts, request, requestOptions) {\n    const stackTrace = []; // eslint-disable-line functional/prefer-readonly-type\n    /**\r\n     * First we prepare the payload that do not depend from hosts.\r\n     */ const data = serializeData(request, requestOptions);\n    const headers = serializeHeaders(transporter, requestOptions);\n    const method = request.method;\n    // On `GET`, the data is proxied to query parameters.\n    const dataQueryParameters = request.method !== MethodEnum.Get ? {} : {\n        ...request.data,\n        ...requestOptions.data\n    };\n    const queryParameters = {\n        \"x-algolia-agent\": transporter.userAgent.value,\n        ...transporter.queryParameters,\n        ...dataQueryParameters,\n        ...requestOptions.queryParameters\n    };\n    let timeoutsCount = 0; // eslint-disable-line functional/no-let\n    const retry = (hosts, getTimeout)=>{\n        /**\r\n         * We iterate on each host, until there is no host left.\r\n         */ const host = hosts.pop(); // eslint-disable-line functional/immutable-data\n        if (host === undefined) {\n            throw createRetryError(stackTraceWithoutCredentials(stackTrace));\n        }\n        const payload = {\n            data,\n            headers,\n            method,\n            url: serializeUrl(host, request.path, queryParameters),\n            connectTimeout: getTimeout(timeoutsCount, transporter.timeouts.connect),\n            responseTimeout: getTimeout(timeoutsCount, requestOptions.timeout)\n        };\n        /**\r\n         * The stackFrame is pushed to the stackTrace so we\r\n         * can have information about onRetry and onFailure\r\n         * decisions.\r\n         */ const pushToStackTrace = (response)=>{\n            const stackFrame = {\n                request: payload,\n                response,\n                host,\n                triesLeft: hosts.length\n            };\n            // eslint-disable-next-line functional/immutable-data\n            stackTrace.push(stackFrame);\n            return stackFrame;\n        };\n        const decisions = {\n            onSuccess: (response)=>deserializeSuccess(response),\n            onRetry (response) {\n                const stackFrame = pushToStackTrace(response);\n                /**\r\n                 * If response is a timeout, we increaset the number of\r\n                 * timeouts so we can increase the timeout later.\r\n                 */ if (response.isTimedOut) {\n                    timeoutsCount++;\n                }\n                return Promise.all([\n                    /**\r\n                     * Failures are individually send the logger, allowing\r\n                     * the end user to debug / store stack frames even\r\n                     * when a retry error does not happen.\r\n                     */ transporter.logger.info(\"Retryable failure\", stackFrameWithoutCredentials(stackFrame)),\n                    /**\r\n                     * We also store the state of the host in failure cases. If the host, is\r\n                     * down it will remain down for the next 2 minutes. In a timeout situation,\r\n                     * this host will be added end of the list of hosts on the next request.\r\n                     */ transporter.hostsCache.set(host, createStatefulHost(host, response.isTimedOut ? HostStatusEnum.Timeouted : HostStatusEnum.Down))\n                ]).then(()=>retry(hosts, getTimeout));\n            },\n            onFail (response) {\n                pushToStackTrace(response);\n                throw deserializeFailure(response, stackTraceWithoutCredentials(stackTrace));\n            }\n        };\n        return transporter.requester.send(payload).then((response)=>{\n            return retryDecision(response, decisions);\n        });\n    };\n    /**\r\n     * Finally, for each retryable host perform request until we got a non\r\n     * retryable response. Some notes here:\r\n     *\r\n     * 1. The reverse here is applied so we can apply a `pop` later on => more performant.\r\n     * 2. We also get from the retryable options a timeout multiplier that is tailored\r\n     * for the current context.\r\n     */ return createRetryableOptions(transporter.hostsCache, statelessHosts).then((options)=>{\n        return retry([\n            ...options.statelessHosts\n        ].reverse(), options.getTimeout);\n    });\n}\nfunction createTransporter(options) {\n    const { hostsCache, logger, requester, requestsCache, responsesCache, timeouts, userAgent, hosts, queryParameters, headers } = options;\n    const transporter = {\n        hostsCache,\n        logger,\n        requester,\n        requestsCache,\n        responsesCache,\n        timeouts,\n        userAgent,\n        headers,\n        queryParameters,\n        hosts: hosts.map((host)=>createStatelessHost(host)),\n        read (request, requestOptions) {\n            /**\r\n             * First, we compute the user request options. Now, keep in mind,\r\n             * that using request options the user is able to modified the intire\r\n             * payload of the request. Such as headers, query parameters, and others.\r\n             */ const mappedRequestOptions = createMappedRequestOptions(requestOptions, transporter.timeouts.read);\n            const createRetryableRequest = ()=>{\n                /**\r\n                 * Then, we prepare a function factory that contains the construction of\r\n                 * the retryable request. At this point, we may *not* perform the actual\r\n                 * request. But we want to have the function factory ready.\r\n                 */ return retryableRequest(transporter, transporter.hosts.filter((host)=>(host.accept & CallEnum.Read) !== 0), request, mappedRequestOptions);\n            };\n            /**\r\n             * Once we have the function factory ready, we need to determine of the\r\n             * request is \"cacheable\" - should be cached. Note that, once again,\r\n             * the user can force this option.\r\n             */ const cacheable = mappedRequestOptions.cacheable !== undefined ? mappedRequestOptions.cacheable : request.cacheable;\n            /**\r\n             * If is not \"cacheable\", we immediatly trigger the retryable request, no\r\n             * need to check cache implementations.\r\n             */ if (cacheable !== true) {\n                return createRetryableRequest();\n            }\n            /**\r\n             * If the request is \"cacheable\", we need to first compute the key to ask\r\n             * the cache implementations if this request is on progress or if the\r\n             * response already exists on the cache.\r\n             */ const key = {\n                request,\n                mappedRequestOptions,\n                transporter: {\n                    queryParameters: transporter.queryParameters,\n                    headers: transporter.headers\n                }\n            };\n            /**\r\n             * With the computed key, we first ask the responses cache\r\n             * implemention if this request was been resolved before.\r\n             */ return transporter.responsesCache.get(key, ()=>{\n                /**\r\n                 * If the request has never resolved before, we actually ask if there\r\n                 * is a current request with the same key on progress.\r\n                 */ return transporter.requestsCache.get(key, ()=>{\n                    return transporter.requestsCache/**\r\n                         * Finally, if there is no request in progress with the same key,\r\n                         * this `createRetryableRequest()` will actually trigger the\r\n                         * retryable request.\r\n                         */ .set(key, createRetryableRequest()).then((response)=>Promise.all([\n                            transporter.requestsCache.delete(key),\n                            response\n                        ]), (err)=>Promise.all([\n                            transporter.requestsCache.delete(key),\n                            Promise.reject(err)\n                        ])).then(([_, response])=>response);\n                });\n            }, {\n                /**\r\n                 * Of course, once we get this response back from the server, we\r\n                 * tell response cache to actually store the received response\r\n                 * to be used later.\r\n                 */ miss: (response)=>transporter.responsesCache.set(key, response)\n            });\n        },\n        write (request, requestOptions) {\n            /**\r\n             * On write requests, no cache mechanisms are applied, and we\r\n             * proxy the request immediately to the requester.\r\n             */ return retryableRequest(transporter, transporter.hosts.filter((host)=>(host.accept & CallEnum.Write) !== 0), request, createMappedRequestOptions(requestOptions, transporter.timeouts.write));\n        }\n    };\n    return transporter;\n}\nfunction createUserAgent(version) {\n    const userAgent = {\n        value: `Algolia for JavaScript (${version})`,\n        add (options) {\n            const addedUserAgent = `; ${options.segment}${options.version !== undefined ? ` (${options.version})` : \"\"}`;\n            if (userAgent.value.indexOf(addedUserAgent) === -1) {\n                // eslint-disable-next-line functional/immutable-data\n                userAgent.value = `${userAgent.value}${addedUserAgent}`;\n            }\n            return userAgent;\n        }\n    };\n    return userAgent;\n}\nfunction deserializeSuccess(response) {\n    // eslint-disable-next-line functional/no-try-statement\n    try {\n        return JSON.parse(response.content);\n    } catch (e) {\n        throw createDeserializationError(e.message, response);\n    }\n}\nfunction deserializeFailure({ content, status }, stackFrame) {\n    // eslint-disable-next-line functional/no-let\n    let message = content;\n    // eslint-disable-next-line functional/no-try-statement\n    try {\n        message = JSON.parse(content).message;\n    } catch (e) {\n    // ..\n    }\n    return createApiError(message, status, stackFrame);\n}\nfunction serializeUrl(host, path, queryParameters) {\n    const queryParametersAsString = serializeQueryParameters(queryParameters);\n    // eslint-disable-next-line functional/no-let\n    let url = `${host.protocol}://${host.url}/${path.charAt(0) === \"/\" ? path.substr(1) : path}`;\n    if (queryParametersAsString.length) {\n        url += `?${queryParametersAsString}`;\n    }\n    return url;\n}\nfunction serializeQueryParameters(parameters) {\n    const isObjectOrArray = (value)=>Object.prototype.toString.call(value) === \"[object Object]\" || Object.prototype.toString.call(value) === \"[object Array]\";\n    return Object.keys(parameters).map((key)=>encode(\"%s=%s\", key, isObjectOrArray(parameters[key]) ? JSON.stringify(parameters[key]) : parameters[key])).join(\"&\");\n}\nfunction serializeData(request, requestOptions) {\n    if (request.method === MethodEnum.Get || request.data === undefined && requestOptions.data === undefined) {\n        return undefined;\n    }\n    const data = Array.isArray(request.data) ? request.data : {\n        ...request.data,\n        ...requestOptions.data\n    };\n    return JSON.stringify(data);\n}\nfunction serializeHeaders(transporter, requestOptions) {\n    const headers = {\n        ...transporter.headers,\n        ...requestOptions.headers\n    };\n    const serializedHeaders = {};\n    Object.keys(headers).forEach((header)=>{\n        const value = headers[header];\n        // @ts-ignore\n        // eslint-disable-next-line functional/immutable-data\n        serializedHeaders[header.toLowerCase()] = value;\n    });\n    return serializedHeaders;\n}\nfunction stackTraceWithoutCredentials(stackTrace) {\n    return stackTrace.map((stackFrame)=>stackFrameWithoutCredentials(stackFrame));\n}\nfunction stackFrameWithoutCredentials(stackFrame) {\n    const modifiedHeaders = stackFrame.request.headers[\"x-algolia-api-key\"] ? {\n        \"x-algolia-api-key\": \"*****\"\n    } : {};\n    return {\n        ...stackFrame,\n        request: {\n            ...stackFrame.request,\n            headers: {\n                ...stackFrame.request.headers,\n                ...modifiedHeaders\n            }\n        }\n    };\n}\nfunction createApiError(message, status, transporterStackTrace) {\n    return {\n        name: \"ApiError\",\n        message,\n        status,\n        transporterStackTrace\n    };\n}\nfunction createDeserializationError(message, response) {\n    return {\n        name: \"DeserializationError\",\n        message,\n        response\n    };\n}\nfunction createRetryError(transporterStackTrace) {\n    return {\n        name: \"RetryError\",\n        message: \"Unreachable hosts - your application id may be incorrect. If the error persists, contact support@algolia.com.\",\n        transporterStackTrace\n    };\n}\nconst createSearchClient = (options)=>{\n    const appId = options.appId;\n    const auth = createAuth(options.authMode !== undefined ? options.authMode : AuthMode.WithinHeaders, appId, options.apiKey);\n    const transporter = createTransporter({\n        hosts: [\n            {\n                url: `${appId}-dsn.algolia.net`,\n                accept: CallEnum.Read\n            },\n            {\n                url: `${appId}.algolia.net`,\n                accept: CallEnum.Write\n            }\n        ].concat(shuffle([\n            {\n                url: `${appId}-1.algolianet.com`\n            },\n            {\n                url: `${appId}-2.algolianet.com`\n            },\n            {\n                url: `${appId}-3.algolianet.com`\n            }\n        ])),\n        ...options,\n        headers: {\n            ...auth.headers(),\n            ...{\n                \"content-type\": \"application/x-www-form-urlencoded\"\n            },\n            ...options.headers\n        },\n        queryParameters: {\n            ...auth.queryParameters(),\n            ...options.queryParameters\n        }\n    });\n    const base = {\n        transporter,\n        appId,\n        addAlgoliaAgent (segment, version) {\n            transporter.userAgent.add({\n                segment,\n                version\n            });\n        },\n        clearCache () {\n            return Promise.all([\n                transporter.requestsCache.clear(),\n                transporter.responsesCache.clear()\n            ]).then(()=>undefined);\n        }\n    };\n    return addMethods(base, options.methods);\n};\nconst customRequest = (base)=>{\n    return (request, requestOptions)=>{\n        if (request.method === MethodEnum.Get) {\n            return base.transporter.read(request, requestOptions);\n        }\n        return base.transporter.write(request, requestOptions);\n    };\n};\nconst initIndex = (base)=>{\n    return (indexName, options = {})=>{\n        const searchIndex = {\n            transporter: base.transporter,\n            appId: base.appId,\n            indexName\n        };\n        return addMethods(searchIndex, options.methods);\n    };\n};\nconst multipleQueries = (base)=>{\n    return (queries, requestOptions)=>{\n        const requests = queries.map((query)=>{\n            return {\n                ...query,\n                params: serializeQueryParameters(query.params || {})\n            };\n        });\n        return base.transporter.read({\n            method: MethodEnum.Post,\n            path: \"1/indexes/*/queries\",\n            data: {\n                requests\n            },\n            cacheable: true\n        }, requestOptions);\n    };\n};\nconst multipleSearchForFacetValues = (base)=>{\n    return (queries, requestOptions)=>{\n        return Promise.all(queries.map((query)=>{\n            const { facetName, facetQuery, ...params } = query.params;\n            return initIndex(base)(query.indexName, {\n                methods: {\n                    searchForFacetValues\n                }\n            }).searchForFacetValues(facetName, facetQuery, {\n                ...requestOptions,\n                ...params\n            });\n        }));\n    };\n};\nconst findAnswers = (base)=>{\n    return (query, queryLanguages, requestOptions)=>{\n        return base.transporter.read({\n            method: MethodEnum.Post,\n            path: encode(\"1/answers/%s/prediction\", base.indexName),\n            data: {\n                query,\n                queryLanguages\n            },\n            cacheable: true\n        }, requestOptions);\n    };\n};\nconst search = (base)=>{\n    return (query, requestOptions)=>{\n        return base.transporter.read({\n            method: MethodEnum.Post,\n            path: encode(\"1/indexes/%s/query\", base.indexName),\n            data: {\n                query\n            },\n            cacheable: true\n        }, requestOptions);\n    };\n};\nconst searchForFacetValues = (base)=>{\n    return (facetName, facetQuery, requestOptions)=>{\n        return base.transporter.read({\n            method: MethodEnum.Post,\n            path: encode(\"1/indexes/%s/facets/%s/query\", base.indexName, facetName),\n            data: {\n                facetQuery\n            },\n            cacheable: true\n        }, requestOptions);\n    };\n};\nconst LogLevelEnum = {\n    Debug: 1,\n    Info: 2,\n    Error: 3\n};\n/* eslint no-console: 0 */ function createConsoleLogger(logLevel) {\n    return {\n        debug (message, args) {\n            if (LogLevelEnum.Debug >= logLevel) {\n                console.debug(message, args);\n            }\n            return Promise.resolve();\n        },\n        info (message, args) {\n            if (LogLevelEnum.Info >= logLevel) {\n                console.info(message, args);\n            }\n            return Promise.resolve();\n        },\n        error (message, args) {\n            console.error(message, args);\n            return Promise.resolve();\n        }\n    };\n}\nfunction createBrowserXhrRequester() {\n    return {\n        send (request) {\n            return new Promise((resolve)=>{\n                const baseRequester = new XMLHttpRequest();\n                baseRequester.open(request.method, request.url, true);\n                Object.keys(request.headers).forEach((key)=>baseRequester.setRequestHeader(key, request.headers[key]));\n                const createTimeout = (timeout, content)=>{\n                    return setTimeout(()=>{\n                        baseRequester.abort();\n                        resolve({\n                            status: 0,\n                            content,\n                            isTimedOut: true\n                        });\n                    }, timeout * 1000);\n                };\n                const connectTimeout = createTimeout(request.connectTimeout, \"Connection timeout\");\n                // eslint-disable-next-line functional/no-let\n                let responseTimeout;\n                // eslint-disable-next-line functional/immutable-data\n                baseRequester.onreadystatechange = ()=>{\n                    if (baseRequester.readyState > baseRequester.OPENED && responseTimeout === undefined) {\n                        clearTimeout(connectTimeout);\n                        responseTimeout = createTimeout(request.responseTimeout, \"Socket timeout\");\n                    }\n                };\n                // eslint-disable-next-line functional/immutable-data\n                baseRequester.onerror = ()=>{\n                    // istanbul ignore next\n                    if (baseRequester.status === 0) {\n                        clearTimeout(connectTimeout);\n                        clearTimeout(responseTimeout);\n                        resolve({\n                            content: baseRequester.responseText || \"Network request failed\",\n                            status: baseRequester.status,\n                            isTimedOut: false\n                        });\n                    }\n                };\n                //  eslint-disable-next-line functional/immutable-data\n                baseRequester.onload = ()=>{\n                    clearTimeout(connectTimeout);\n                    clearTimeout(responseTimeout);\n                    resolve({\n                        content: baseRequester.responseText,\n                        status: baseRequester.status,\n                        isTimedOut: false\n                    });\n                };\n                baseRequester.send(request.data);\n            });\n        }\n    };\n}\nfunction algoliasearch(appId, apiKey, options) {\n    const commonOptions = {\n        appId,\n        apiKey,\n        timeouts: {\n            connect: 1,\n            read: 2,\n            write: 30\n        },\n        requester: createBrowserXhrRequester(),\n        logger: createConsoleLogger(LogLevelEnum.Error),\n        responsesCache: createInMemoryCache(),\n        requestsCache: createInMemoryCache({\n            serializable: false\n        }),\n        hostsCache: createFallbackableCache({\n            caches: [\n                createBrowserLocalStorageCache({\n                    key: `${version}-${appId}`\n                }),\n                createInMemoryCache()\n            ]\n        }),\n        userAgent: createUserAgent(version).add({\n            segment: \"Browser\",\n            version: \"lite\"\n        }),\n        authMode: AuthMode.WithinQueryParameters\n    };\n    return createSearchClient({\n        ...commonOptions,\n        ...options,\n        methods: {\n            search: multipleQueries,\n            searchForFacetValues: multipleSearchForFacetValues,\n            multipleQueries,\n            multipleSearchForFacetValues,\n            customRequest,\n            initIndex: (base)=>(indexName)=>{\n                    return initIndex(base)(indexName, {\n                        methods: {\n                            search,\n                            searchForFacetValues,\n                            findAnswers\n                        }\n                    });\n                }\n        }\n    });\n}\n// eslint-disable-next-line functional/immutable-data\nalgoliasearch.version = version;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (algoliasearch);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWxnb2xpYXNlYXJjaC9kaXN0L2FsZ29saWFzZWFyY2gtbGl0ZS5lc20uYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBU0EsK0JBQStCQyxPQUFPO0lBQzNDLE1BQU1DLGVBQWUsQ0FBQyx3QkFBd0IsRUFBRUQsUUFBUUUsR0FBRyxDQUFDLENBQUM7SUFDN0QsNkNBQTZDO0lBQzdDLElBQUlDO0lBQ0osTUFBTUMsYUFBYTtRQUNmLElBQUlELFlBQVlFLFdBQVc7WUFDdkJGLFVBQVVILFFBQVFNLFlBQVksSUFBSUMsT0FBT0QsWUFBWTtRQUN6RDtRQUNBLE9BQU9IO0lBQ1g7SUFDQSxNQUFNSyxlQUFlO1FBQ2pCLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ04sYUFBYU8sT0FBTyxDQUFDVixpQkFBaUI7SUFDNUQ7SUFDQSxNQUFNVyxlQUFlLENBQUNDO1FBQ2xCVCxhQUFhVSxPQUFPLENBQUNiLGNBQWNRLEtBQUtNLFNBQVMsQ0FBQ0Y7SUFDdEQ7SUFDQSxNQUFNRywyQkFBMkI7UUFDN0IsTUFBTUMsYUFBYWpCLFFBQVFpQixVQUFVLEdBQUdqQixRQUFRaUIsVUFBVSxHQUFHLE9BQU87UUFDcEUsTUFBTUosWUFBWUw7UUFDbEIsTUFBTVUsaURBQWlEQyxPQUFPQyxXQUFXLENBQUNELE9BQU9FLE9BQU8sQ0FBQ1IsV0FBV1MsTUFBTSxDQUFDLENBQUMsR0FBR0MsVUFBVTtZQUNySCxPQUFPQSxVQUFVQyxTQUFTLEtBQUtuQjtRQUNuQztRQUNBTyxhQUFhTTtRQUNiLElBQUksQ0FBQ0QsWUFDRDtRQUNKLE1BQU1RLHVDQUF1Q04sT0FBT0MsV0FBVyxDQUFDRCxPQUFPRSxPQUFPLENBQUNILGdEQUFnREksTUFBTSxDQUFDLENBQUMsR0FBR0MsVUFBVTtZQUNoSixNQUFNRyxtQkFBbUIsSUFBSUMsT0FBT0MsT0FBTztZQUMzQyxNQUFNQyxZQUFZTixVQUFVQyxTQUFTLEdBQUdQLGFBQWFTO1lBQ3JELE9BQU8sQ0FBQ0c7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YUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zsb3diaXRlLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL2FsZ29saWFzZWFyY2gvZGlzdC9hbGdvbGlhc2VhcmNoLWxpdGUuZXNtLmJyb3dzZXIuanM/MmNlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBjcmVhdGVCcm93c2VyTG9jYWxTdG9yYWdlQ2FjaGUob3B0aW9ucykge1xyXG4gICAgY29uc3QgbmFtZXNwYWNlS2V5ID0gYGFsZ29saWFzZWFyY2gtY2xpZW50LWpzLSR7b3B0aW9ucy5rZXl9YDtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL25vLWxldFxyXG4gICAgbGV0IHN0b3JhZ2U7XHJcbiAgICBjb25zdCBnZXRTdG9yYWdlID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChzdG9yYWdlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgc3RvcmFnZSA9IG9wdGlvbnMubG9jYWxTdG9yYWdlIHx8IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdG9yYWdlO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGdldE5hbWVzcGFjZSA9ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShnZXRTdG9yYWdlKCkuZ2V0SXRlbShuYW1lc3BhY2VLZXkpIHx8ICd7fScpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHNldE5hbWVzcGFjZSA9IChuYW1lc3BhY2UpID0+IHtcclxuICAgICAgICBnZXRTdG9yYWdlKCkuc2V0SXRlbShuYW1lc3BhY2VLZXksIEpTT04uc3RyaW5naWZ5KG5hbWVzcGFjZSkpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbW92ZU91dGRhdGVkQ2FjaGVJdGVtcyA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCB0aW1lVG9MaXZlID0gb3B0aW9ucy50aW1lVG9MaXZlID8gb3B0aW9ucy50aW1lVG9MaXZlICogMTAwMCA6IG51bGw7XHJcbiAgICAgICAgY29uc3QgbmFtZXNwYWNlID0gZ2V0TmFtZXNwYWNlKCk7XHJcbiAgICAgICAgY29uc3QgZmlsdGVyZWROYW1lc3BhY2VXaXRob3V0T2xkRm9ybWF0dGVkQ2FjaGVJdGVtcyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhuYW1lc3BhY2UpLmZpbHRlcigoWywgY2FjaGVJdGVtXSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVJdGVtLnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBzZXROYW1lc3BhY2UoZmlsdGVyZWROYW1lc3BhY2VXaXRob3V0T2xkRm9ybWF0dGVkQ2FjaGVJdGVtcyk7XHJcbiAgICAgICAgaWYgKCF0aW1lVG9MaXZlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgZmlsdGVyZWROYW1lc3BhY2VXaXRob3V0RXhwaXJlZEl0ZW1zID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGZpbHRlcmVkTmFtZXNwYWNlV2l0aG91dE9sZEZvcm1hdHRlZENhY2hlSXRlbXMpLmZpbHRlcigoWywgY2FjaGVJdGVtXSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzRXhwaXJlZCA9IGNhY2hlSXRlbS50aW1lc3RhbXAgKyB0aW1lVG9MaXZlIDwgY3VycmVudFRpbWVzdGFtcDtcclxuICAgICAgICAgICAgcmV0dXJuICFpc0V4cGlyZWQ7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHNldE5hbWVzcGFjZShmaWx0ZXJlZE5hbWVzcGFjZVdpdGhvdXRFeHBpcmVkSXRlbXMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0KGtleSwgZGVmYXVsdFZhbHVlLCBldmVudHMgPSB7XHJcbiAgICAgICAgICAgIG1pc3M6ICgpID0+IFByb21pc2UucmVzb2x2ZSgpLFxyXG4gICAgICAgIH0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVPdXRkYXRlZENhY2hlSXRlbXMoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleUFzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoa2V5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBnZXROYW1lc3BhY2UoKVtrZXlBc1N0cmluZ107XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbih2YWx1ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3ZhbHVlID8gdmFsdWUudmFsdWUgOiBkZWZhdWx0VmFsdWUoKSwgdmFsdWUgIT09IHVuZGVmaW5lZF0pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKFt2YWx1ZSwgZXhpc3RzXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFt2YWx1ZSwgZXhpc3RzIHx8IGV2ZW50cy5taXNzKHZhbHVlKV0pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKFt2YWx1ZV0pID0+IHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWVzcGFjZSA9IGdldE5hbWVzcGFjZSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGFcclxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZVtKU09OLnN0cmluZ2lmeShrZXkpXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGdldFN0b3JhZ2UoKS5zZXRJdGVtKG5hbWVzcGFjZUtleSwgSlNPTi5zdHJpbmdpZnkobmFtZXNwYWNlKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVsZXRlKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lc3BhY2UgPSBnZXROYW1lc3BhY2UoKTtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXHJcbiAgICAgICAgICAgICAgICBkZWxldGUgbmFtZXNwYWNlW0pTT04uc3RyaW5naWZ5KGtleSldO1xyXG4gICAgICAgICAgICAgICAgZ2V0U3RvcmFnZSgpLnNldEl0ZW0obmFtZXNwYWNlS2V5LCBKU09OLnN0cmluZ2lmeShuYW1lc3BhY2UpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbGVhcigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZ2V0U3RvcmFnZSgpLnJlbW92ZUl0ZW0obmFtZXNwYWNlS2V5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cblxuLy8gQHRvZG8gQWRkIGxvZ2dlciBvbiBvcHRpb25zIHRvIGRlYnVnIHdoZW4gY2FjaGVzIGdvIHdyb25nLlxyXG5mdW5jdGlvbiBjcmVhdGVGYWxsYmFja2FibGVDYWNoZShvcHRpb25zKSB7XHJcbiAgICBjb25zdCBjYWNoZXMgPSBbLi4ub3B0aW9ucy5jYWNoZXNdO1xyXG4gICAgY29uc3QgY3VycmVudCA9IGNhY2hlcy5zaGlmdCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGFcclxuICAgIGlmIChjdXJyZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlTnVsbENhY2hlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldChrZXksIGRlZmF1bHRWYWx1ZSwgZXZlbnRzID0ge1xyXG4gICAgICAgICAgICBtaXNzOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSxcclxuICAgICAgICB9KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50LmdldChrZXksIGRlZmF1bHRWYWx1ZSwgZXZlbnRzKS5jYXRjaCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRmFsbGJhY2thYmxlQ2FjaGUoeyBjYWNoZXMgfSkuZ2V0KGtleSwgZGVmYXVsdFZhbHVlLCBldmVudHMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50LnNldChrZXksIHZhbHVlKS5jYXRjaCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRmFsbGJhY2thYmxlQ2FjaGUoeyBjYWNoZXMgfSkuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlbGV0ZShrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuZGVsZXRlKGtleSkuY2F0Y2goKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZhbGxiYWNrYWJsZUNhY2hlKHsgY2FjaGVzIH0pLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsZWFyKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudC5jbGVhcigpLmNhdGNoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVGYWxsYmFja2FibGVDYWNoZSh7IGNhY2hlcyB9KS5jbGVhcigpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVOdWxsQ2FjaGUoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldChfa2V5LCBkZWZhdWx0VmFsdWUsIGV2ZW50cyA9IHtcclxuICAgICAgICAgICAgbWlzczogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCksXHJcbiAgICAgICAgfSkge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRlZmF1bHRWYWx1ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVcclxuICAgICAgICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiBQcm9taXNlLmFsbChbcmVzdWx0LCBldmVudHMubWlzcyhyZXN1bHQpXSkpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoW3Jlc3VsdF0pID0+IHJlc3VsdCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQoX2tleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZWxldGUoX2tleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbGVhcigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluTWVtb3J5Q2FjaGUob3B0aW9ucyA9IHsgc2VyaWFsaXphYmxlOiB0cnVlIH0pIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL25vLWxldFxyXG4gICAgbGV0IGNhY2hlID0ge307XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldChrZXksIGRlZmF1bHRWYWx1ZSwgZXZlbnRzID0ge1xyXG4gICAgICAgICAgICBtaXNzOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSxcclxuICAgICAgICB9KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleUFzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoa2V5KTtcclxuICAgICAgICAgICAgaWYgKGtleUFzU3RyaW5nIGluIGNhY2hlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMuc2VyaWFsaXphYmxlID8gSlNPTi5wYXJzZShjYWNoZVtrZXlBc1N0cmluZ10pIDogY2FjaGVba2V5QXNTdHJpbmddKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gZGVmYXVsdFZhbHVlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pc3MgPSAoZXZlbnRzICYmIGV2ZW50cy5taXNzKSB8fCAoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKCh2YWx1ZSkgPT4gbWlzcyh2YWx1ZSkpLnRoZW4oKCkgPT4gcHJvbWlzZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgICAgICAgICBjYWNoZVtKU09OLnN0cmluZ2lmeShrZXkpXSA9IG9wdGlvbnMuc2VyaWFsaXphYmxlID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVsZXRlKGtleSkge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgICAgICAgICBkZWxldGUgY2FjaGVbSlNPTi5zdHJpbmdpZnkoa2V5KV07XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsZWFyKCkge1xyXG4gICAgICAgICAgICBjYWNoZSA9IHt9O1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXV0aChhdXRoTW9kZSwgYXBwSWQsIGFwaUtleSkge1xyXG4gICAgY29uc3QgY3JlZGVudGlhbHMgPSB7XHJcbiAgICAgICAgJ3gtYWxnb2xpYS1hcGkta2V5JzogYXBpS2V5LFxyXG4gICAgICAgICd4LWFsZ29saWEtYXBwbGljYXRpb24taWQnOiBhcHBJZCxcclxuICAgIH07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGhlYWRlcnMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhdXRoTW9kZSA9PT0gQXV0aE1vZGUuV2l0aGluSGVhZGVycyA/IGNyZWRlbnRpYWxzIDoge307XHJcbiAgICAgICAgfSxcclxuICAgICAgICBxdWVyeVBhcmFtZXRlcnMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhdXRoTW9kZSA9PT0gQXV0aE1vZGUuV2l0aGluUXVlcnlQYXJhbWV0ZXJzID8gY3JlZGVudGlhbHMgOiB7fTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9wcmVmZXItcmVhZG9ubHktdHlwZVxyXG5mdW5jdGlvbiBzaHVmZmxlKGFycmF5KSB7XHJcbiAgICBsZXQgYyA9IGFycmF5Lmxlbmd0aCAtIDE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuY3Rpb25hbC9uby1sZXRcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL25vLWxvb3Atc3RhdGVtZW50XHJcbiAgICBmb3IgKGM7IGMgPiAwOyBjLS0pIHtcclxuICAgICAgICBjb25zdCBiID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGMgKyAxKSk7XHJcbiAgICAgICAgY29uc3QgYSA9IGFycmF5W2NdO1xyXG4gICAgICAgIGFycmF5W2NdID0gYXJyYXlbYl07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YSwgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICBhcnJheVtiXSA9IGE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YSwgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgIH1cclxuICAgIHJldHVybiBhcnJheTtcclxufVxyXG5mdW5jdGlvbiBhZGRNZXRob2RzKGJhc2UsIG1ldGhvZHMpIHtcclxuICAgIGlmICghbWV0aG9kcykge1xyXG4gICAgICAgIHJldHVybiBiYXNlO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmtleXMobWV0aG9kcykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhLCBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgIGJhc2Vba2V5XSA9IG1ldGhvZHNba2V5XShiYXNlKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGJhc2U7XHJcbn1cclxuZnVuY3Rpb24gZW5jb2RlKGZvcm1hdCwgLi4uYXJncykge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvbm8tbGV0XHJcbiAgICBsZXQgaSA9IDA7XHJcbiAgICByZXR1cm4gZm9ybWF0LnJlcGxhY2UoLyVzL2csICgpID0+IGVuY29kZVVSSUNvbXBvbmVudChhcmdzW2krK10pKTtcclxufVxuXG5jb25zdCB2ZXJzaW9uID0gJzQuMjIuMCc7XG5cbmNvbnN0IEF1dGhNb2RlID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBhdXRoIGNyZWRlbnRpYWxzIHNob3VsZCBiZSBpbiBxdWVyeSBwYXJhbWV0ZXJzLlxyXG4gICAgICovXHJcbiAgICBXaXRoaW5RdWVyeVBhcmFtZXRlcnM6IDAsXHJcbiAgICAvKipcclxuICAgICAqIElmIGF1dGggY3JlZGVudGlhbHMgc2hvdWxkIGJlIGluIGhlYWRlcnMuXHJcbiAgICAgKi9cclxuICAgIFdpdGhpbkhlYWRlcnM6IDEsXHJcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcHBlZFJlcXVlc3RPcHRpb25zKHJlcXVlc3RPcHRpb25zLCB0aW1lb3V0KSB7XHJcbiAgICBjb25zdCBvcHRpb25zID0gcmVxdWVzdE9wdGlvbnMgfHwge307XHJcbiAgICBjb25zdCBkYXRhID0gb3B0aW9ucy5kYXRhIHx8IHt9O1xyXG4gICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIGlmIChbJ3RpbWVvdXQnLCAnaGVhZGVycycsICdxdWVyeVBhcmFtZXRlcnMnLCAnZGF0YScsICdjYWNoZWFibGUnXS5pbmRleE9mKGtleSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IG9wdGlvbnNba2V5XTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGRhdGE6IE9iamVjdC5lbnRyaWVzKGRhdGEpLmxlbmd0aCA+IDAgPyBkYXRhIDogdW5kZWZpbmVkLFxyXG4gICAgICAgIHRpbWVvdXQ6IG9wdGlvbnMudGltZW91dCB8fCB0aW1lb3V0LFxyXG4gICAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyB8fCB7fSxcclxuICAgICAgICBxdWVyeVBhcmFtZXRlcnM6IG9wdGlvbnMucXVlcnlQYXJhbWV0ZXJzIHx8IHt9LFxyXG4gICAgICAgIGNhY2hlYWJsZTogb3B0aW9ucy5jYWNoZWFibGUsXHJcbiAgICB9O1xyXG59XG5cbmNvbnN0IENhbGxFbnVtID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgaG9zdCBpcyByZWFkIG9ubHkuXHJcbiAgICAgKi9cclxuICAgIFJlYWQ6IDEsXHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBob3N0IGlzIHdyaXRlIG9ubHkuXHJcbiAgICAgKi9cclxuICAgIFdyaXRlOiAyLFxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgaG9zdCBpcyBib3RoIHJlYWQgYW5kIHdyaXRlLlxyXG4gICAgICovXHJcbiAgICBBbnk6IDMsXHJcbn07XG5cbmNvbnN0IEhvc3RTdGF0dXNFbnVtID0ge1xyXG4gICAgVXA6IDEsXHJcbiAgICBEb3duOiAyLFxyXG4gICAgVGltZW91dGVkOiAzLFxyXG59O1xuXG4vLyBCeSBkZWZhdWx0LCBBUEkgQ2xpZW50cyBhdCBBbGdvbGlhIGhhdmUgZXhwaXJhdGlvbiBkZWxheVxyXG4vLyBvZiA1IG1pbnMuIEluIHRoZSBKYXZhU2NyaXB0IGNsaWVudCwgd2UgaGF2ZSAyIG1pbnMuXHJcbmNvbnN0IEVYUElSQVRJT05fREVMQVkgPSAyICogNjAgKiAxMDAwO1xyXG5mdW5jdGlvbiBjcmVhdGVTdGF0ZWZ1bEhvc3QoaG9zdCwgc3RhdHVzID0gSG9zdFN0YXR1c0VudW0uVXApIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4uaG9zdCxcclxuICAgICAgICBzdGF0dXMsXHJcbiAgICAgICAgbGFzdFVwZGF0ZTogRGF0ZS5ub3coKSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNTdGF0ZWZ1bEhvc3RVcChob3N0KSB7XHJcbiAgICByZXR1cm4gaG9zdC5zdGF0dXMgPT09IEhvc3RTdGF0dXNFbnVtLlVwIHx8IERhdGUubm93KCkgLSBob3N0Lmxhc3RVcGRhdGUgPiBFWFBJUkFUSU9OX0RFTEFZO1xyXG59XHJcbmZ1bmN0aW9uIGlzU3RhdGVmdWxIb3N0VGltZW91dGVkKGhvc3QpIHtcclxuICAgIHJldHVybiAoaG9zdC5zdGF0dXMgPT09IEhvc3RTdGF0dXNFbnVtLlRpbWVvdXRlZCAmJiBEYXRlLm5vdygpIC0gaG9zdC5sYXN0VXBkYXRlIDw9IEVYUElSQVRJT05fREVMQVkpO1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlbGVzc0hvc3Qob3B0aW9ucykge1xyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByb3RvY29sOiAnaHR0cHMnLFxyXG4gICAgICAgICAgICB1cmw6IG9wdGlvbnMsXHJcbiAgICAgICAgICAgIGFjY2VwdDogQ2FsbEVudW0uQW55LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByb3RvY29sOiBvcHRpb25zLnByb3RvY29sIHx8ICdodHRwcycsXHJcbiAgICAgICAgdXJsOiBvcHRpb25zLnVybCxcclxuICAgICAgICBhY2NlcHQ6IG9wdGlvbnMuYWNjZXB0IHx8IENhbGxFbnVtLkFueSxcclxuICAgIH07XHJcbn1cblxuY29uc3QgTWV0aG9kRW51bSA9IHtcclxuICAgIERlbGV0ZTogJ0RFTEVURScsXHJcbiAgICBHZXQ6ICdHRVQnLFxyXG4gICAgUG9zdDogJ1BPU1QnLFxyXG4gICAgUHV0OiAnUFVUJyxcclxufTtcblxuZnVuY3Rpb24gY3JlYXRlUmV0cnlhYmxlT3B0aW9ucyhob3N0c0NhY2hlLCBzdGF0ZWxlc3NIb3N0cykge1xyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHN0YXRlbGVzc0hvc3RzLm1hcChzdGF0ZWxlc3NIb3N0ID0+IHtcclxuICAgICAgICByZXR1cm4gaG9zdHNDYWNoZS5nZXQoc3RhdGVsZXNzSG9zdCwgKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZVN0YXRlZnVsSG9zdChzdGF0ZWxlc3NIb3N0KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KSkudGhlbihzdGF0ZWZ1bEhvc3RzID0+IHtcclxuICAgICAgICBjb25zdCBob3N0c1VwID0gc3RhdGVmdWxIb3N0cy5maWx0ZXIoaG9zdCA9PiBpc1N0YXRlZnVsSG9zdFVwKGhvc3QpKTtcclxuICAgICAgICBjb25zdCBob3N0c1RpbWVvdXRlZCA9IHN0YXRlZnVsSG9zdHMuZmlsdGVyKGhvc3QgPT4gaXNTdGF0ZWZ1bEhvc3RUaW1lb3V0ZWQoaG9zdCkpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE5vdGUsIHdlIHB1dCB0aGUgaG9zdHMgdGhhdCBwcmV2aW91c2x5IHRpbWVvdXRlZCBvbiB0aGUgZW5kIG9mIHRoZSBsaXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0IGhvc3RzQXZhaWxhYmxlID0gWy4uLmhvc3RzVXAsIC4uLmhvc3RzVGltZW91dGVkXTtcclxuICAgICAgICBjb25zdCBzdGF0ZWxlc3NIb3N0c0F2YWlsYWJsZSA9IGhvc3RzQXZhaWxhYmxlLmxlbmd0aCA+IDBcclxuICAgICAgICAgICAgPyBob3N0c0F2YWlsYWJsZS5tYXAoaG9zdCA9PiBjcmVhdGVTdGF0ZWxlc3NIb3N0KGhvc3QpKVxyXG4gICAgICAgICAgICA6IHN0YXRlbGVzc0hvc3RzO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGdldFRpbWVvdXQodGltZW91dHNDb3VudCwgYmFzZVRpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSW1hZ2luZSB0aGF0IHlvdSBoYXZlIDQgaG9zdHMsIGlmIHRpbWVvdXRzIHdpbGwgaW5jcmVhc2VcclxuICAgICAgICAgICAgICAgICAqIG9uIHRoZSBmb2xsb3dpbmcgd2F5OiAxICh0aW1lb3V0ZWQpID4gNCAodGltZW91dGVkKSA+IDUgKDIwMClcclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQsIHRoZSB2ZXJ5IG5leHQgcmVxdWVzdCwgd2Ugc3RhcnQgZnJvbSB0aGUgcHJldmlvdXMgdGltZW91dFxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICA1ICh0aW1lb3V0ZWQpID4gNiAodGltZW91dGVkKSA+IDcgLi4uXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogVGhpcyBzdHJhdGVneSBtYXkgbmVlZCB0byBiZSByZXZpZXdlZCwgYnV0IGlzIHRoZSBzdHJhdGVneSBvbiB0aGUgb3VyXHJcbiAgICAgICAgICAgICAgICAgKiBjdXJyZW50IHYzIHZlcnNpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRNdWx0aXBsaWVyID0gaG9zdHNUaW1lb3V0ZWQubGVuZ3RoID09PSAwICYmIHRpbWVvdXRzQ291bnQgPT09IDBcclxuICAgICAgICAgICAgICAgICAgICA/IDFcclxuICAgICAgICAgICAgICAgICAgICA6IGhvc3RzVGltZW91dGVkLmxlbmd0aCArIDMgKyB0aW1lb3V0c0NvdW50O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVvdXRNdWx0aXBsaWVyICogYmFzZVRpbWVvdXQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0YXRlbGVzc0hvc3RzOiBzdGF0ZWxlc3NIb3N0c0F2YWlsYWJsZSxcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cblxuY29uc3QgaXNOZXR3b3JrRXJyb3IgPSAoeyBpc1RpbWVkT3V0LCBzdGF0dXMgfSkgPT4ge1xyXG4gICAgcmV0dXJuICFpc1RpbWVkT3V0ICYmIH5+c3RhdHVzID09PSAwO1xyXG59O1xyXG5jb25zdCBpc1JldHJ5YWJsZSA9IChyZXNwb25zZSkgPT4ge1xyXG4gICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xyXG4gICAgY29uc3QgaXNUaW1lZE91dCA9IHJlc3BvbnNlLmlzVGltZWRPdXQ7XHJcbiAgICByZXR1cm4gKGlzVGltZWRPdXQgfHwgaXNOZXR3b3JrRXJyb3IocmVzcG9uc2UpIHx8ICh+fihzdGF0dXMgLyAxMDApICE9PSAyICYmIH5+KHN0YXR1cyAvIDEwMCkgIT09IDQpKTtcclxufTtcclxuY29uc3QgaXNTdWNjZXNzID0gKHsgc3RhdHVzIH0pID0+IHtcclxuICAgIHJldHVybiB+fihzdGF0dXMgLyAxMDApID09PSAyO1xyXG59O1xyXG5jb25zdCByZXRyeURlY2lzaW9uID0gKHJlc3BvbnNlLCBvdXRjb21lcykgPT4ge1xyXG4gICAgaWYgKGlzUmV0cnlhYmxlKHJlc3BvbnNlKSkge1xyXG4gICAgICAgIHJldHVybiBvdXRjb21lcy5vblJldHJ5KHJlc3BvbnNlKTtcclxuICAgIH1cclxuICAgIGlmIChpc1N1Y2Nlc3MocmVzcG9uc2UpKSB7XHJcbiAgICAgICAgcmV0dXJuIG91dGNvbWVzLm9uU3VjY2VzcyhyZXNwb25zZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0Y29tZXMub25GYWlsKHJlc3BvbnNlKTtcclxufTtcblxuZnVuY3Rpb24gcmV0cnlhYmxlUmVxdWVzdCh0cmFuc3BvcnRlciwgc3RhdGVsZXNzSG9zdHMsIHJlcXVlc3QsIHJlcXVlc3RPcHRpb25zKSB7XHJcbiAgICBjb25zdCBzdGFja1RyYWNlID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuY3Rpb25hbC9wcmVmZXItcmVhZG9ubHktdHlwZVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJzdCB3ZSBwcmVwYXJlIHRoZSBwYXlsb2FkIHRoYXQgZG8gbm90IGRlcGVuZCBmcm9tIGhvc3RzLlxyXG4gICAgICovXHJcbiAgICBjb25zdCBkYXRhID0gc2VyaWFsaXplRGF0YShyZXF1ZXN0LCByZXF1ZXN0T3B0aW9ucyk7XHJcbiAgICBjb25zdCBoZWFkZXJzID0gc2VyaWFsaXplSGVhZGVycyh0cmFuc3BvcnRlciwgcmVxdWVzdE9wdGlvbnMpO1xyXG4gICAgY29uc3QgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XHJcbiAgICAvLyBPbiBgR0VUYCwgdGhlIGRhdGEgaXMgcHJveGllZCB0byBxdWVyeSBwYXJhbWV0ZXJzLlxyXG4gICAgY29uc3QgZGF0YVF1ZXJ5UGFyYW1ldGVycyA9IHJlcXVlc3QubWV0aG9kICE9PSBNZXRob2RFbnVtLkdldFxyXG4gICAgICAgID8ge31cclxuICAgICAgICA6IHtcclxuICAgICAgICAgICAgLi4ucmVxdWVzdC5kYXRhLFxyXG4gICAgICAgICAgICAuLi5yZXF1ZXN0T3B0aW9ucy5kYXRhLFxyXG4gICAgICAgIH07XHJcbiAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgJ3gtYWxnb2xpYS1hZ2VudCc6IHRyYW5zcG9ydGVyLnVzZXJBZ2VudC52YWx1ZSxcclxuICAgICAgICAuLi50cmFuc3BvcnRlci5xdWVyeVBhcmFtZXRlcnMsXHJcbiAgICAgICAgLi4uZGF0YVF1ZXJ5UGFyYW1ldGVycyxcclxuICAgICAgICAuLi5yZXF1ZXN0T3B0aW9ucy5xdWVyeVBhcmFtZXRlcnMsXHJcbiAgICB9O1xyXG4gICAgbGV0IHRpbWVvdXRzQ291bnQgPSAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmN0aW9uYWwvbm8tbGV0XHJcbiAgICBjb25zdCByZXRyeSA9IChob3N0cywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jdGlvbmFsL3ByZWZlci1yZWFkb25seS10eXBlXHJcbiAgICBnZXRUaW1lb3V0KSA9PiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2UgaXRlcmF0ZSBvbiBlYWNoIGhvc3QsIHVudGlsIHRoZXJlIGlzIG5vIGhvc3QgbGVmdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdCBob3N0ID0gaG9zdHMucG9wKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgICAgIGlmIChob3N0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlUmV0cnlFcnJvcihzdGFja1RyYWNlV2l0aG91dENyZWRlbnRpYWxzKHN0YWNrVHJhY2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcclxuICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgaGVhZGVycyxcclxuICAgICAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgICAgICB1cmw6IHNlcmlhbGl6ZVVybChob3N0LCByZXF1ZXN0LnBhdGgsIHF1ZXJ5UGFyYW1ldGVycyksXHJcbiAgICAgICAgICAgIGNvbm5lY3RUaW1lb3V0OiBnZXRUaW1lb3V0KHRpbWVvdXRzQ291bnQsIHRyYW5zcG9ydGVyLnRpbWVvdXRzLmNvbm5lY3QpLFxyXG4gICAgICAgICAgICByZXNwb25zZVRpbWVvdXQ6IGdldFRpbWVvdXQodGltZW91dHNDb3VudCwgcmVxdWVzdE9wdGlvbnMudGltZW91dCksXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc3RhY2tGcmFtZSBpcyBwdXNoZWQgdG8gdGhlIHN0YWNrVHJhY2Ugc28gd2VcclxuICAgICAgICAgKiBjYW4gaGF2ZSBpbmZvcm1hdGlvbiBhYm91dCBvblJldHJ5IGFuZCBvbkZhaWx1cmVcclxuICAgICAgICAgKiBkZWNpc2lvbnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc3QgcHVzaFRvU3RhY2tUcmFjZSA9IChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzdGFja0ZyYW1lID0ge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogcGF5bG9hZCxcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxyXG4gICAgICAgICAgICAgICAgaG9zdCxcclxuICAgICAgICAgICAgICAgIHRyaWVzTGVmdDogaG9zdHMubGVuZ3RoLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgICAgICAgICBzdGFja1RyYWNlLnB1c2goc3RhY2tGcmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGFja0ZyYW1lO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgZGVjaXNpb25zID0ge1xyXG4gICAgICAgICAgICBvblN1Y2Nlc3M6IHJlc3BvbnNlID0+IGRlc2VyaWFsaXplU3VjY2VzcyhyZXNwb25zZSksXHJcbiAgICAgICAgICAgIG9uUmV0cnkocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YWNrRnJhbWUgPSBwdXNoVG9TdGFja1RyYWNlKHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSWYgcmVzcG9uc2UgaXMgYSB0aW1lb3V0LCB3ZSBpbmNyZWFzZXQgdGhlIG51bWJlciBvZlxyXG4gICAgICAgICAgICAgICAgICogdGltZW91dHMgc28gd2UgY2FuIGluY3JlYXNlIHRoZSB0aW1lb3V0IGxhdGVyLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuaXNUaW1lZE91dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRzQ291bnQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogRmFpbHVyZXMgYXJlIGluZGl2aWR1YWxseSBzZW5kIHRoZSBsb2dnZXIsIGFsbG93aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICogdGhlIGVuZCB1c2VyIHRvIGRlYnVnIC8gc3RvcmUgc3RhY2sgZnJhbWVzIGV2ZW5cclxuICAgICAgICAgICAgICAgICAgICAgKiB3aGVuIGEgcmV0cnkgZXJyb3IgZG9lcyBub3QgaGFwcGVuLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydGVyLmxvZ2dlci5pbmZvKCdSZXRyeWFibGUgZmFpbHVyZScsIHN0YWNrRnJhbWVXaXRob3V0Q3JlZGVudGlhbHMoc3RhY2tGcmFtZSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFdlIGFsc28gc3RvcmUgdGhlIHN0YXRlIG9mIHRoZSBob3N0IGluIGZhaWx1cmUgY2FzZXMuIElmIHRoZSBob3N0LCBpc1xyXG4gICAgICAgICAgICAgICAgICAgICAqIGRvd24gaXQgd2lsbCByZW1haW4gZG93biBmb3IgdGhlIG5leHQgMiBtaW51dGVzLiBJbiBhIHRpbWVvdXQgc2l0dWF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAqIHRoaXMgaG9zdCB3aWxsIGJlIGFkZGVkIGVuZCBvZiB0aGUgbGlzdCBvZiBob3N0cyBvbiB0aGUgbmV4dCByZXF1ZXN0LlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydGVyLmhvc3RzQ2FjaGUuc2V0KGhvc3QsIGNyZWF0ZVN0YXRlZnVsSG9zdChob3N0LCByZXNwb25zZS5pc1RpbWVkT3V0ID8gSG9zdFN0YXR1c0VudW0uVGltZW91dGVkIDogSG9zdFN0YXR1c0VudW0uRG93bikpLFxyXG4gICAgICAgICAgICAgICAgXSkudGhlbigoKSA9PiByZXRyeShob3N0cywgZ2V0VGltZW91dCkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkZhaWwocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIHB1c2hUb1N0YWNrVHJhY2UocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZGVzZXJpYWxpemVGYWlsdXJlKHJlc3BvbnNlLCBzdGFja1RyYWNlV2l0aG91dENyZWRlbnRpYWxzKHN0YWNrVHJhY2UpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0cmFuc3BvcnRlci5yZXF1ZXN0ZXIuc2VuZChwYXlsb2FkKS50aGVuKHJlc3BvbnNlID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHJldHJ5RGVjaXNpb24ocmVzcG9uc2UsIGRlY2lzaW9ucyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5hbGx5LCBmb3IgZWFjaCByZXRyeWFibGUgaG9zdCBwZXJmb3JtIHJlcXVlc3QgdW50aWwgd2UgZ290IGEgbm9uXHJcbiAgICAgKiByZXRyeWFibGUgcmVzcG9uc2UuIFNvbWUgbm90ZXMgaGVyZTpcclxuICAgICAqXHJcbiAgICAgKiAxLiBUaGUgcmV2ZXJzZSBoZXJlIGlzIGFwcGxpZWQgc28gd2UgY2FuIGFwcGx5IGEgYHBvcGAgbGF0ZXIgb24gPT4gbW9yZSBwZXJmb3JtYW50LlxyXG4gICAgICogMi4gV2UgYWxzbyBnZXQgZnJvbSB0aGUgcmV0cnlhYmxlIG9wdGlvbnMgYSB0aW1lb3V0IG11bHRpcGxpZXIgdGhhdCBpcyB0YWlsb3JlZFxyXG4gICAgICogZm9yIHRoZSBjdXJyZW50IGNvbnRleHQuXHJcbiAgICAgKi9cclxuICAgIHJldHVybiBjcmVhdGVSZXRyeWFibGVPcHRpb25zKHRyYW5zcG9ydGVyLmhvc3RzQ2FjaGUsIHN0YXRlbGVzc0hvc3RzKS50aGVuKG9wdGlvbnMgPT4ge1xyXG4gICAgICAgIHJldHVybiByZXRyeShbLi4ub3B0aW9ucy5zdGF0ZWxlc3NIb3N0c10ucmV2ZXJzZSgpLCBvcHRpb25zLmdldFRpbWVvdXQpO1xyXG4gICAgfSk7XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHJhbnNwb3J0ZXIob3B0aW9ucykge1xyXG4gICAgY29uc3QgeyBob3N0c0NhY2hlLCBsb2dnZXIsIHJlcXVlc3RlciwgcmVxdWVzdHNDYWNoZSwgcmVzcG9uc2VzQ2FjaGUsIHRpbWVvdXRzLCB1c2VyQWdlbnQsIGhvc3RzLCBxdWVyeVBhcmFtZXRlcnMsIGhlYWRlcnMsIH0gPSBvcHRpb25zO1xyXG4gICAgY29uc3QgdHJhbnNwb3J0ZXIgPSB7XHJcbiAgICAgICAgaG9zdHNDYWNoZSxcclxuICAgICAgICBsb2dnZXIsXHJcbiAgICAgICAgcmVxdWVzdGVyLFxyXG4gICAgICAgIHJlcXVlc3RzQ2FjaGUsXHJcbiAgICAgICAgcmVzcG9uc2VzQ2FjaGUsXHJcbiAgICAgICAgdGltZW91dHMsXHJcbiAgICAgICAgdXNlckFnZW50LFxyXG4gICAgICAgIGhlYWRlcnMsXHJcbiAgICAgICAgcXVlcnlQYXJhbWV0ZXJzLFxyXG4gICAgICAgIGhvc3RzOiBob3N0cy5tYXAoaG9zdCA9PiBjcmVhdGVTdGF0ZWxlc3NIb3N0KGhvc3QpKSxcclxuICAgICAgICByZWFkKHJlcXVlc3QsIHJlcXVlc3RPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGaXJzdCwgd2UgY29tcHV0ZSB0aGUgdXNlciByZXF1ZXN0IG9wdGlvbnMuIE5vdywga2VlcCBpbiBtaW5kLFxyXG4gICAgICAgICAgICAgKiB0aGF0IHVzaW5nIHJlcXVlc3Qgb3B0aW9ucyB0aGUgdXNlciBpcyBhYmxlIHRvIG1vZGlmaWVkIHRoZSBpbnRpcmVcclxuICAgICAgICAgICAgICogcGF5bG9hZCBvZiB0aGUgcmVxdWVzdC4gU3VjaCBhcyBoZWFkZXJzLCBxdWVyeSBwYXJhbWV0ZXJzLCBhbmQgb3RoZXJzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY29uc3QgbWFwcGVkUmVxdWVzdE9wdGlvbnMgPSBjcmVhdGVNYXBwZWRSZXF1ZXN0T3B0aW9ucyhyZXF1ZXN0T3B0aW9ucywgdHJhbnNwb3J0ZXIudGltZW91dHMucmVhZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZVJldHJ5YWJsZVJlcXVlc3QgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZW4sIHdlIHByZXBhcmUgYSBmdW5jdGlvbiBmYWN0b3J5IHRoYXQgY29udGFpbnMgdGhlIGNvbnN0cnVjdGlvbiBvZlxyXG4gICAgICAgICAgICAgICAgICogdGhlIHJldHJ5YWJsZSByZXF1ZXN0LiBBdCB0aGlzIHBvaW50LCB3ZSBtYXkgKm5vdCogcGVyZm9ybSB0aGUgYWN0dWFsXHJcbiAgICAgICAgICAgICAgICAgKiByZXF1ZXN0LiBCdXQgd2Ugd2FudCB0byBoYXZlIHRoZSBmdW5jdGlvbiBmYWN0b3J5IHJlYWR5LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0cnlhYmxlUmVxdWVzdCh0cmFuc3BvcnRlciwgdHJhbnNwb3J0ZXIuaG9zdHMuZmlsdGVyKGhvc3QgPT4gKGhvc3QuYWNjZXB0ICYgQ2FsbEVudW0uUmVhZCkgIT09IDApLCByZXF1ZXN0LCBtYXBwZWRSZXF1ZXN0T3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPbmNlIHdlIGhhdmUgdGhlIGZ1bmN0aW9uIGZhY3RvcnkgcmVhZHksIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIG9mIHRoZVxyXG4gICAgICAgICAgICAgKiByZXF1ZXN0IGlzIFwiY2FjaGVhYmxlXCIgLSBzaG91bGQgYmUgY2FjaGVkLiBOb3RlIHRoYXQsIG9uY2UgYWdhaW4sXHJcbiAgICAgICAgICAgICAqIHRoZSB1c2VyIGNhbiBmb3JjZSB0aGlzIG9wdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlYWJsZSA9IG1hcHBlZFJlcXVlc3RPcHRpb25zLmNhY2hlYWJsZSAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICA/IG1hcHBlZFJlcXVlc3RPcHRpb25zLmNhY2hlYWJsZVxyXG4gICAgICAgICAgICAgICAgOiByZXF1ZXN0LmNhY2hlYWJsZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIElmIGlzIG5vdCBcImNhY2hlYWJsZVwiLCB3ZSBpbW1lZGlhdGx5IHRyaWdnZXIgdGhlIHJldHJ5YWJsZSByZXF1ZXN0LCBub1xyXG4gICAgICAgICAgICAgKiBuZWVkIHRvIGNoZWNrIGNhY2hlIGltcGxlbWVudGF0aW9ucy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmIChjYWNoZWFibGUgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVSZXRyeWFibGVSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIElmIHRoZSByZXF1ZXN0IGlzIFwiY2FjaGVhYmxlXCIsIHdlIG5lZWQgdG8gZmlyc3QgY29tcHV0ZSB0aGUga2V5IHRvIGFza1xyXG4gICAgICAgICAgICAgKiB0aGUgY2FjaGUgaW1wbGVtZW50YXRpb25zIGlmIHRoaXMgcmVxdWVzdCBpcyBvbiBwcm9ncmVzcyBvciBpZiB0aGVcclxuICAgICAgICAgICAgICogcmVzcG9uc2UgYWxyZWFkeSBleGlzdHMgb24gdGhlIGNhY2hlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY29uc3Qga2V5ID0ge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcclxuICAgICAgICAgICAgICAgIG1hcHBlZFJlcXVlc3RPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0ZXI6IHtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnM6IHRyYW5zcG9ydGVyLnF1ZXJ5UGFyYW1ldGVycyxcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0cmFuc3BvcnRlci5oZWFkZXJzLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdpdGggdGhlIGNvbXB1dGVkIGtleSwgd2UgZmlyc3QgYXNrIHRoZSByZXNwb25zZXMgY2FjaGVcclxuICAgICAgICAgICAgICogaW1wbGVtZW50aW9uIGlmIHRoaXMgcmVxdWVzdCB3YXMgYmVlbiByZXNvbHZlZCBiZWZvcmUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICByZXR1cm4gdHJhbnNwb3J0ZXIucmVzcG9uc2VzQ2FjaGUuZ2V0KGtleSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGUgcmVxdWVzdCBoYXMgbmV2ZXIgcmVzb2x2ZWQgYmVmb3JlLCB3ZSBhY3R1YWxseSBhc2sgaWYgdGhlcmVcclxuICAgICAgICAgICAgICAgICAqIGlzIGEgY3VycmVudCByZXF1ZXN0IHdpdGggdGhlIHNhbWUga2V5IG9uIHByb2dyZXNzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNwb3J0ZXIucmVxdWVzdHNDYWNoZS5nZXQoa2V5LCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0cmFuc3BvcnRlci5yZXF1ZXN0c0NhY2hlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBGaW5hbGx5LCBpZiB0aGVyZSBpcyBubyByZXF1ZXN0IGluIHByb2dyZXNzIHdpdGggdGhlIHNhbWUga2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGlzIGBjcmVhdGVSZXRyeWFibGVSZXF1ZXN0KClgIHdpbGwgYWN0dWFsbHkgdHJpZ2dlciB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogcmV0cnlhYmxlIHJlcXVlc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0KGtleSwgY3JlYXRlUmV0cnlhYmxlUmVxdWVzdCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiBQcm9taXNlLmFsbChbdHJhbnNwb3J0ZXIucmVxdWVzdHNDYWNoZS5kZWxldGUoa2V5KSwgcmVzcG9uc2VdKSwgZXJyID0+IFByb21pc2UuYWxsKFt0cmFuc3BvcnRlci5yZXF1ZXN0c0NhY2hlLmRlbGV0ZShrZXkpLCBQcm9taXNlLnJlamVjdChlcnIpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChbXywgcmVzcG9uc2VdKSA9PiByZXNwb25zZSkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogT2YgY291cnNlLCBvbmNlIHdlIGdldCB0aGlzIHJlc3BvbnNlIGJhY2sgZnJvbSB0aGUgc2VydmVyLCB3ZVxyXG4gICAgICAgICAgICAgICAgICogdGVsbCByZXNwb25zZSBjYWNoZSB0byBhY3R1YWxseSBzdG9yZSB0aGUgcmVjZWl2ZWQgcmVzcG9uc2VcclxuICAgICAgICAgICAgICAgICAqIHRvIGJlIHVzZWQgbGF0ZXIuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIG1pc3M6IHJlc3BvbnNlID0+IHRyYW5zcG9ydGVyLnJlc3BvbnNlc0NhY2hlLnNldChrZXksIHJlc3BvbnNlKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB3cml0ZShyZXF1ZXN0LCByZXF1ZXN0T3B0aW9ucykge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogT24gd3JpdGUgcmVxdWVzdHMsIG5vIGNhY2hlIG1lY2hhbmlzbXMgYXJlIGFwcGxpZWQsIGFuZCB3ZVxyXG4gICAgICAgICAgICAgKiBwcm94eSB0aGUgcmVxdWVzdCBpbW1lZGlhdGVseSB0byB0aGUgcmVxdWVzdGVyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgcmV0dXJuIHJldHJ5YWJsZVJlcXVlc3QodHJhbnNwb3J0ZXIsIHRyYW5zcG9ydGVyLmhvc3RzLmZpbHRlcihob3N0ID0+IChob3N0LmFjY2VwdCAmIENhbGxFbnVtLldyaXRlKSAhPT0gMCksIHJlcXVlc3QsIGNyZWF0ZU1hcHBlZFJlcXVlc3RPcHRpb25zKHJlcXVlc3RPcHRpb25zLCB0cmFuc3BvcnRlci50aW1lb3V0cy53cml0ZSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHRyYW5zcG9ydGVyO1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVzZXJBZ2VudCh2ZXJzaW9uKSB7XHJcbiAgICBjb25zdCB1c2VyQWdlbnQgPSB7XHJcbiAgICAgICAgdmFsdWU6IGBBbGdvbGlhIGZvciBKYXZhU2NyaXB0ICgke3ZlcnNpb259KWAsXHJcbiAgICAgICAgYWRkKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY29uc3QgYWRkZWRVc2VyQWdlbnQgPSBgOyAke29wdGlvbnMuc2VnbWVudH0ke29wdGlvbnMudmVyc2lvbiAhPT0gdW5kZWZpbmVkID8gYCAoJHtvcHRpb25zLnZlcnNpb259KWAgOiAnJ31gO1xyXG4gICAgICAgICAgICBpZiAodXNlckFnZW50LnZhbHVlLmluZGV4T2YoYWRkZWRVc2VyQWdlbnQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGFcclxuICAgICAgICAgICAgICAgIHVzZXJBZ2VudC52YWx1ZSA9IGAke3VzZXJBZ2VudC52YWx1ZX0ke2FkZGVkVXNlckFnZW50fWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVzZXJBZ2VudDtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuICAgIHJldHVybiB1c2VyQWdlbnQ7XHJcbn1cblxuZnVuY3Rpb24gZGVzZXJpYWxpemVTdWNjZXNzKHJlc3BvbnNlKSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9uby10cnktc3RhdGVtZW50XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3BvbnNlLmNvbnRlbnQpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVEZXNlcmlhbGl6YXRpb25FcnJvcihlLm1lc3NhZ2UsIHJlc3BvbnNlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUZhaWx1cmUoeyBjb250ZW50LCBzdGF0dXMgfSwgc3RhY2tGcmFtZSkge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvbm8tbGV0XHJcbiAgICBsZXQgbWVzc2FnZSA9IGNvbnRlbnQ7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9uby10cnktc3RhdGVtZW50XHJcbiAgICB0cnkge1xyXG4gICAgICAgIG1lc3NhZ2UgPSBKU09OLnBhcnNlKGNvbnRlbnQpLm1lc3NhZ2U7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIC4uXHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlQXBpRXJyb3IobWVzc2FnZSwgc3RhdHVzLCBzdGFja0ZyYW1lKTtcclxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVVcmwoaG9zdCwgcGF0aCwgcXVlcnlQYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnNBc1N0cmluZyA9IHNlcmlhbGl6ZVF1ZXJ5UGFyYW1ldGVycyhxdWVyeVBhcmFtZXRlcnMpO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvbm8tbGV0XHJcbiAgICBsZXQgdXJsID0gYCR7aG9zdC5wcm90b2NvbH06Ly8ke2hvc3QudXJsfS8ke3BhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGh9YDtcclxuICAgIGlmIChxdWVyeVBhcmFtZXRlcnNBc1N0cmluZy5sZW5ndGgpIHtcclxuICAgICAgICB1cmwgKz0gYD8ke3F1ZXJ5UGFyYW1ldGVyc0FzU3RyaW5nfWA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdXJsO1xyXG59XHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZVF1ZXJ5UGFyYW1ldGVycyhwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBpc09iamVjdE9yQXJyYXkgPSAodmFsdWUpID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nIHx8XHJcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhwYXJhbWV0ZXJzKVxyXG4gICAgICAgIC5tYXAoa2V5ID0+IGVuY29kZSgnJXM9JXMnLCBrZXksIGlzT2JqZWN0T3JBcnJheShwYXJhbWV0ZXJzW2tleV0pID8gSlNPTi5zdHJpbmdpZnkocGFyYW1ldGVyc1trZXldKSA6IHBhcmFtZXRlcnNba2V5XSkpXHJcbiAgICAgICAgLmpvaW4oJyYnKTtcclxufVxyXG5mdW5jdGlvbiBzZXJpYWxpemVEYXRhKHJlcXVlc3QsIHJlcXVlc3RPcHRpb25zKSB7XHJcbiAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IE1ldGhvZEVudW0uR2V0IHx8XHJcbiAgICAgICAgKHJlcXVlc3QuZGF0YSA9PT0gdW5kZWZpbmVkICYmIHJlcXVlc3RPcHRpb25zLmRhdGEgPT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGF0YSA9IEFycmF5LmlzQXJyYXkocmVxdWVzdC5kYXRhKVxyXG4gICAgICAgID8gcmVxdWVzdC5kYXRhXHJcbiAgICAgICAgOiB7IC4uLnJlcXVlc3QuZGF0YSwgLi4ucmVxdWVzdE9wdGlvbnMuZGF0YSB9O1xyXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG59XHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZUhlYWRlcnModHJhbnNwb3J0ZXIsIHJlcXVlc3RPcHRpb25zKSB7XHJcbiAgICBjb25zdCBoZWFkZXJzID0ge1xyXG4gICAgICAgIC4uLnRyYW5zcG9ydGVyLmhlYWRlcnMsXHJcbiAgICAgICAgLi4ucmVxdWVzdE9wdGlvbnMuaGVhZGVycyxcclxuICAgIH07XHJcbiAgICBjb25zdCBzZXJpYWxpemVkSGVhZGVycyA9IHt9O1xyXG4gICAgT2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaChoZWFkZXIgPT4ge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gaGVhZGVyc1toZWFkZXJdO1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgICAgIHNlcmlhbGl6ZWRIZWFkZXJzW2hlYWRlci50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gc2VyaWFsaXplZEhlYWRlcnM7XHJcbn1cblxuZnVuY3Rpb24gc3RhY2tUcmFjZVdpdGhvdXRDcmVkZW50aWFscyhzdGFja1RyYWNlKSB7XHJcbiAgICByZXR1cm4gc3RhY2tUcmFjZS5tYXAoc3RhY2tGcmFtZSA9PiBzdGFja0ZyYW1lV2l0aG91dENyZWRlbnRpYWxzKHN0YWNrRnJhbWUpKTtcclxufVxyXG5mdW5jdGlvbiBzdGFja0ZyYW1lV2l0aG91dENyZWRlbnRpYWxzKHN0YWNrRnJhbWUpIHtcclxuICAgIGNvbnN0IG1vZGlmaWVkSGVhZGVycyA9IHN0YWNrRnJhbWUucmVxdWVzdC5oZWFkZXJzWyd4LWFsZ29saWEtYXBpLWtleSddXHJcbiAgICAgICAgPyB7ICd4LWFsZ29saWEtYXBpLWtleSc6ICcqKioqKicgfVxyXG4gICAgICAgIDoge307XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLnN0YWNrRnJhbWUsXHJcbiAgICAgICAgcmVxdWVzdDoge1xyXG4gICAgICAgICAgICAuLi5zdGFja0ZyYW1lLnJlcXVlc3QsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgIC4uLnN0YWNrRnJhbWUucmVxdWVzdC5oZWFkZXJzLFxyXG4gICAgICAgICAgICAgICAgLi4ubW9kaWZpZWRIZWFkZXJzLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFwaUVycm9yKG1lc3NhZ2UsIHN0YXR1cywgdHJhbnNwb3J0ZXJTdGFja1RyYWNlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWU6ICdBcGlFcnJvcicsXHJcbiAgICAgICAgbWVzc2FnZSxcclxuICAgICAgICBzdGF0dXMsXHJcbiAgICAgICAgdHJhbnNwb3J0ZXJTdGFja1RyYWNlLFxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZXNlcmlhbGl6YXRpb25FcnJvcihtZXNzYWdlLCByZXNwb25zZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lOiAnRGVzZXJpYWxpemF0aW9uRXJyb3InLFxyXG4gICAgICAgIG1lc3NhZ2UsXHJcbiAgICAgICAgcmVzcG9uc2UsXHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJldHJ5RXJyb3IodHJhbnNwb3J0ZXJTdGFja1RyYWNlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWU6ICdSZXRyeUVycm9yJyxcclxuICAgICAgICBtZXNzYWdlOiAnVW5yZWFjaGFibGUgaG9zdHMgLSB5b3VyIGFwcGxpY2F0aW9uIGlkIG1heSBiZSBpbmNvcnJlY3QuIElmIHRoZSBlcnJvciBwZXJzaXN0cywgY29udGFjdCBzdXBwb3J0QGFsZ29saWEuY29tLicsXHJcbiAgICAgICAgdHJhbnNwb3J0ZXJTdGFja1RyYWNlLFxyXG4gICAgfTtcclxufVxuXG5jb25zdCBjcmVhdGVTZWFyY2hDbGllbnQgPSBvcHRpb25zID0+IHtcclxuICAgIGNvbnN0IGFwcElkID0gb3B0aW9ucy5hcHBJZDtcclxuICAgIGNvbnN0IGF1dGggPSBjcmVhdGVBdXRoKG9wdGlvbnMuYXV0aE1vZGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYXV0aE1vZGUgOiBBdXRoTW9kZS5XaXRoaW5IZWFkZXJzLCBhcHBJZCwgb3B0aW9ucy5hcGlLZXkpO1xyXG4gICAgY29uc3QgdHJhbnNwb3J0ZXIgPSBjcmVhdGVUcmFuc3BvcnRlcih7XHJcbiAgICAgICAgaG9zdHM6IFtcclxuICAgICAgICAgICAgeyB1cmw6IGAke2FwcElkfS1kc24uYWxnb2xpYS5uZXRgLCBhY2NlcHQ6IENhbGxFbnVtLlJlYWQgfSxcclxuICAgICAgICAgICAgeyB1cmw6IGAke2FwcElkfS5hbGdvbGlhLm5ldGAsIGFjY2VwdDogQ2FsbEVudW0uV3JpdGUgfSxcclxuICAgICAgICBdLmNvbmNhdChzaHVmZmxlKFtcclxuICAgICAgICAgICAgeyB1cmw6IGAke2FwcElkfS0xLmFsZ29saWFuZXQuY29tYCB9LFxyXG4gICAgICAgICAgICB7IHVybDogYCR7YXBwSWR9LTIuYWxnb2xpYW5ldC5jb21gIH0sXHJcbiAgICAgICAgICAgIHsgdXJsOiBgJHthcHBJZH0tMy5hbGdvbGlhbmV0LmNvbWAgfSxcclxuICAgICAgICBdKSksXHJcbiAgICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgIC4uLmF1dGguaGVhZGVycygpLFxyXG4gICAgICAgICAgICAuLi57ICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyB9LFxyXG4gICAgICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBxdWVyeVBhcmFtZXRlcnM6IHtcclxuICAgICAgICAgICAgLi4uYXV0aC5xdWVyeVBhcmFtZXRlcnMoKSxcclxuICAgICAgICAgICAgLi4ub3B0aW9ucy5xdWVyeVBhcmFtZXRlcnMsXHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgYmFzZSA9IHtcclxuICAgICAgICB0cmFuc3BvcnRlcixcclxuICAgICAgICBhcHBJZCxcclxuICAgICAgICBhZGRBbGdvbGlhQWdlbnQoc2VnbWVudCwgdmVyc2lvbikge1xyXG4gICAgICAgICAgICB0cmFuc3BvcnRlci51c2VyQWdlbnQuYWRkKHsgc2VnbWVudCwgdmVyc2lvbiB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsZWFyQ2FjaGUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRlci5yZXF1ZXN0c0NhY2hlLmNsZWFyKCksXHJcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRlci5yZXNwb25zZXNDYWNoZS5jbGVhcigpLFxyXG4gICAgICAgICAgICBdKS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbiAgICByZXR1cm4gYWRkTWV0aG9kcyhiYXNlLCBvcHRpb25zLm1ldGhvZHMpO1xyXG59O1xuXG5jb25zdCBjdXN0b21SZXF1ZXN0ID0gKGJhc2UpID0+IHtcclxuICAgIHJldHVybiAocmVxdWVzdCwgcmVxdWVzdE9wdGlvbnMpID0+IHtcclxuICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IE1ldGhvZEVudW0uR2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiYXNlLnRyYW5zcG9ydGVyLnJlYWQocmVxdWVzdCwgcmVxdWVzdE9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmFzZS50cmFuc3BvcnRlci53cml0ZShyZXF1ZXN0LCByZXF1ZXN0T3B0aW9ucyk7XHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCBpbml0SW5kZXggPSAoYmFzZSkgPT4ge1xyXG4gICAgcmV0dXJuIChpbmRleE5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHNlYXJjaEluZGV4ID0ge1xyXG4gICAgICAgICAgICB0cmFuc3BvcnRlcjogYmFzZS50cmFuc3BvcnRlcixcclxuICAgICAgICAgICAgYXBwSWQ6IGJhc2UuYXBwSWQsXHJcbiAgICAgICAgICAgIGluZGV4TmFtZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBhZGRNZXRob2RzKHNlYXJjaEluZGV4LCBvcHRpb25zLm1ldGhvZHMpO1xyXG4gICAgfTtcclxufTtcblxuY29uc3QgbXVsdGlwbGVRdWVyaWVzID0gKGJhc2UpID0+IHtcclxuICAgIHJldHVybiAocXVlcmllcywgcmVxdWVzdE9wdGlvbnMpID0+IHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0cyA9IHF1ZXJpZXMubWFwKHF1ZXJ5ID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxyXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBzZXJpYWxpemVRdWVyeVBhcmFtZXRlcnMocXVlcnkucGFyYW1zIHx8IHt9KSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYmFzZS50cmFuc3BvcnRlci5yZWFkKHtcclxuICAgICAgICAgICAgbWV0aG9kOiBNZXRob2RFbnVtLlBvc3QsXHJcbiAgICAgICAgICAgIHBhdGg6ICcxL2luZGV4ZXMvKi9xdWVyaWVzJyxcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdHMsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNhY2hlYWJsZTogdHJ1ZSxcclxuICAgICAgICB9LCByZXF1ZXN0T3B0aW9ucyk7XHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCBtdWx0aXBsZVNlYXJjaEZvckZhY2V0VmFsdWVzID0gKGJhc2UpID0+IHtcclxuICAgIHJldHVybiAocXVlcmllcywgcmVxdWVzdE9wdGlvbnMpID0+IHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocXVlcmllcy5tYXAocXVlcnkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IGZhY2V0TmFtZSwgZmFjZXRRdWVyeSwgLi4ucGFyYW1zIH0gPSBxdWVyeS5wYXJhbXM7XHJcbiAgICAgICAgICAgIHJldHVybiBpbml0SW5kZXgoYmFzZSkocXVlcnkuaW5kZXhOYW1lLCB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2RzOiB7IHNlYXJjaEZvckZhY2V0VmFsdWVzIH0sXHJcbiAgICAgICAgICAgIH0pLnNlYXJjaEZvckZhY2V0VmFsdWVzKGZhY2V0TmFtZSwgZmFjZXRRdWVyeSwge1xyXG4gICAgICAgICAgICAgICAgLi4ucmVxdWVzdE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAuLi5wYXJhbXMsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pKTtcclxuICAgIH07XHJcbn07XG5cbmNvbnN0IGZpbmRBbnN3ZXJzID0gKGJhc2UpID0+IHtcclxuICAgIHJldHVybiAocXVlcnksIHF1ZXJ5TGFuZ3VhZ2VzLCByZXF1ZXN0T3B0aW9ucykgPT4ge1xyXG4gICAgICAgIHJldHVybiBiYXNlLnRyYW5zcG9ydGVyLnJlYWQoe1xyXG4gICAgICAgICAgICBtZXRob2Q6IE1ldGhvZEVudW0uUG9zdCxcclxuICAgICAgICAgICAgcGF0aDogZW5jb2RlKCcxL2Fuc3dlcnMvJXMvcHJlZGljdGlvbicsIGJhc2UuaW5kZXhOYW1lKSxcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgICAgICBxdWVyeUxhbmd1YWdlcyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2FjaGVhYmxlOiB0cnVlLFxyXG4gICAgICAgIH0sIHJlcXVlc3RPcHRpb25zKTtcclxuICAgIH07XHJcbn07XG5cbmNvbnN0IHNlYXJjaCA9IChiYXNlKSA9PiB7XHJcbiAgICByZXR1cm4gKHF1ZXJ5LCByZXF1ZXN0T3B0aW9ucykgPT4ge1xyXG4gICAgICAgIHJldHVybiBiYXNlLnRyYW5zcG9ydGVyLnJlYWQoe1xyXG4gICAgICAgICAgICBtZXRob2Q6IE1ldGhvZEVudW0uUG9zdCxcclxuICAgICAgICAgICAgcGF0aDogZW5jb2RlKCcxL2luZGV4ZXMvJXMvcXVlcnknLCBiYXNlLmluZGV4TmFtZSksXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjYWNoZWFibGU6IHRydWUsXHJcbiAgICAgICAgfSwgcmVxdWVzdE9wdGlvbnMpO1xyXG4gICAgfTtcclxufTtcblxuY29uc3Qgc2VhcmNoRm9yRmFjZXRWYWx1ZXMgPSAoYmFzZSkgPT4ge1xyXG4gICAgcmV0dXJuIChmYWNldE5hbWUsIGZhY2V0UXVlcnksIHJlcXVlc3RPcHRpb25zKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2UudHJhbnNwb3J0ZXIucmVhZCh7XHJcbiAgICAgICAgICAgIG1ldGhvZDogTWV0aG9kRW51bS5Qb3N0LFxyXG4gICAgICAgICAgICBwYXRoOiBlbmNvZGUoJzEvaW5kZXhlcy8lcy9mYWNldHMvJXMvcXVlcnknLCBiYXNlLmluZGV4TmFtZSwgZmFjZXROYW1lKSxcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgZmFjZXRRdWVyeSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2FjaGVhYmxlOiB0cnVlLFxyXG4gICAgICAgIH0sIHJlcXVlc3RPcHRpb25zKTtcclxuICAgIH07XHJcbn07XG5cbmNvbnN0IExvZ0xldmVsRW51bSA9IHtcclxuICAgIERlYnVnOiAxLFxyXG4gICAgSW5mbzogMixcclxuICAgIEVycm9yOiAzLFxyXG59O1xuXG4vKiBlc2xpbnQgbm8tY29uc29sZTogMCAqL1xyXG5mdW5jdGlvbiBjcmVhdGVDb25zb2xlTG9nZ2VyKGxvZ0xldmVsKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGRlYnVnKG1lc3NhZ2UsIGFyZ3MpIHtcclxuICAgICAgICAgICAgaWYgKExvZ0xldmVsRW51bS5EZWJ1ZyA+PSBsb2dMZXZlbCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhtZXNzYWdlLCBhcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbmZvKG1lc3NhZ2UsIGFyZ3MpIHtcclxuICAgICAgICAgICAgaWYgKExvZ0xldmVsRW51bS5JbmZvID49IGxvZ0xldmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8obWVzc2FnZSwgYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXJyb3IobWVzc2FnZSwgYXJncykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIGFyZ3MpO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnJvd3NlclhoclJlcXVlc3RlcigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2VuZChyZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZVJlcXVlc3RlciA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICAgICAgYmFzZVJlcXVlc3Rlci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyZXF1ZXN0LmhlYWRlcnMpLmZvckVhY2goa2V5ID0+IGJhc2VSZXF1ZXN0ZXIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHJlcXVlc3QuaGVhZGVyc1trZXldKSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjcmVhdGVUaW1lb3V0ID0gKHRpbWVvdXQsIGNvbnRlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VSZXF1ZXN0ZXIuYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNUaW1lZE91dDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdGltZW91dCAqIDEwMDApO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RUaW1lb3V0ID0gY3JlYXRlVGltZW91dChyZXF1ZXN0LmNvbm5lY3RUaW1lb3V0LCAnQ29ubmVjdGlvbiB0aW1lb3V0Jyk7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9uby1sZXRcclxuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZVRpbWVvdXQ7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgICAgICAgICAgICAgYmFzZVJlcXVlc3Rlci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VSZXF1ZXN0ZXIucmVhZHlTdGF0ZSA+IGJhc2VSZXF1ZXN0ZXIuT1BFTkVEICYmIHJlc3BvbnNlVGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0VGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVGltZW91dCA9IGNyZWF0ZVRpbWVvdXQocmVxdWVzdC5yZXNwb25zZVRpbWVvdXQsICdTb2NrZXQgdGltZW91dCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgICAgICAgICAgICAgYmFzZVJlcXVlc3Rlci5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VSZXF1ZXN0ZXIuc3RhdHVzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0VGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXNwb25zZVRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGJhc2VSZXF1ZXN0ZXIucmVzcG9uc2VUZXh0IHx8ICdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogYmFzZVJlcXVlc3Rlci5zdGF0dXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1RpbWVkT3V0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8vICBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgICAgICAgICAgICAgYmFzZVJlcXVlc3Rlci5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3RUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVzcG9uc2VUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogYmFzZVJlcXVlc3Rlci5yZXNwb25zZVRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogYmFzZVJlcXVlc3Rlci5zdGF0dXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVGltZWRPdXQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJhc2VSZXF1ZXN0ZXIuc2VuZChyZXF1ZXN0LmRhdGEpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBhbGdvbGlhc2VhcmNoKGFwcElkLCBhcGlLZXksIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGNvbW1vbk9wdGlvbnMgPSB7XHJcbiAgICAgICAgYXBwSWQsXHJcbiAgICAgICAgYXBpS2V5LFxyXG4gICAgICAgIHRpbWVvdXRzOiB7XHJcbiAgICAgICAgICAgIGNvbm5lY3Q6IDEsXHJcbiAgICAgICAgICAgIHJlYWQ6IDIsXHJcbiAgICAgICAgICAgIHdyaXRlOiAzMCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlcXVlc3RlcjogY3JlYXRlQnJvd3NlclhoclJlcXVlc3RlcigpLFxyXG4gICAgICAgIGxvZ2dlcjogY3JlYXRlQ29uc29sZUxvZ2dlcihMb2dMZXZlbEVudW0uRXJyb3IpLFxyXG4gICAgICAgIHJlc3BvbnNlc0NhY2hlOiBjcmVhdGVJbk1lbW9yeUNhY2hlKCksXHJcbiAgICAgICAgcmVxdWVzdHNDYWNoZTogY3JlYXRlSW5NZW1vcnlDYWNoZSh7IHNlcmlhbGl6YWJsZTogZmFsc2UgfSksXHJcbiAgICAgICAgaG9zdHNDYWNoZTogY3JlYXRlRmFsbGJhY2thYmxlQ2FjaGUoe1xyXG4gICAgICAgICAgICBjYWNoZXM6IFtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZUJyb3dzZXJMb2NhbFN0b3JhZ2VDYWNoZSh7IGtleTogYCR7dmVyc2lvbn0tJHthcHBJZH1gIH0pLFxyXG4gICAgICAgICAgICAgICAgY3JlYXRlSW5NZW1vcnlDYWNoZSgpLFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIHVzZXJBZ2VudDogY3JlYXRlVXNlckFnZW50KHZlcnNpb24pLmFkZCh7XHJcbiAgICAgICAgICAgIHNlZ21lbnQ6ICdCcm93c2VyJyxcclxuICAgICAgICAgICAgdmVyc2lvbjogJ2xpdGUnLFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGF1dGhNb2RlOiBBdXRoTW9kZS5XaXRoaW5RdWVyeVBhcmFtZXRlcnMsXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGNyZWF0ZVNlYXJjaENsaWVudCh7XHJcbiAgICAgICAgLi4uY29tbW9uT3B0aW9ucyxcclxuICAgICAgICAuLi5vcHRpb25zLFxyXG4gICAgICAgIG1ldGhvZHM6IHtcclxuICAgICAgICAgICAgc2VhcmNoOiBtdWx0aXBsZVF1ZXJpZXMsXHJcbiAgICAgICAgICAgIHNlYXJjaEZvckZhY2V0VmFsdWVzOiBtdWx0aXBsZVNlYXJjaEZvckZhY2V0VmFsdWVzLFxyXG4gICAgICAgICAgICBtdWx0aXBsZVF1ZXJpZXMsXHJcbiAgICAgICAgICAgIG11bHRpcGxlU2VhcmNoRm9yRmFjZXRWYWx1ZXMsXHJcbiAgICAgICAgICAgIGN1c3RvbVJlcXVlc3QsXHJcbiAgICAgICAgICAgIGluaXRJbmRleDogYmFzZSA9PiAoaW5kZXhOYW1lKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5pdEluZGV4KGJhc2UpKGluZGV4TmFtZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZHM6IHsgc2VhcmNoLCBzZWFyY2hGb3JGYWNldFZhbHVlcywgZmluZEFuc3dlcnMgfSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxufVxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG5hbGdvbGlhc2VhcmNoLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG5leHBvcnQgZGVmYXVsdCBhbGdvbGlhc2VhcmNoO1xuIl0sIm5hbWVzIjpbImNyZWF0ZUJyb3dzZXJMb2NhbFN0b3JhZ2VDYWNoZSIsIm9wdGlvbnMiLCJuYW1lc3BhY2VLZXkiLCJrZXkiLCJzdG9yYWdlIiwiZ2V0U3RvcmFnZSIsInVuZGVmaW5lZCIsImxvY2FsU3RvcmFnZSIsIndpbmRvdyIsImdldE5hbWVzcGFjZSIsIkpTT04iLCJwYXJzZSIsImdldEl0ZW0iLCJzZXROYW1lc3BhY2UiLCJuYW1lc3BhY2UiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwicmVtb3ZlT3V0ZGF0ZWRDYWNoZUl0ZW1zIiwidGltZVRvTGl2ZSIsImZpbHRlcmVkTmFtZXNwYWNlV2l0aG91dE9sZEZvcm1hdHRlZENhY2hlSXRlbXMiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJmaWx0ZXIiLCJjYWNoZUl0ZW0iLCJ0aW1lc3RhbXAiLCJmaWx0ZXJlZE5hbWVzcGFjZVdpdGhvdXRFeHBpcmVkSXRlbXMiLCJjdXJyZW50VGltZXN0YW1wIiwiRGF0ZSIsImdldFRpbWUiLCJpc0V4cGlyZWQiLCJnZXQiLCJkZWZhdWx0VmFsdWUiLCJldmVudHMiLCJtaXNzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwia2V5QXNTdHJpbmciLCJ2YWx1ZSIsImFsbCIsImV4aXN0cyIsInNldCIsImRlbGV0ZSIsImNsZWFyIiwicmVtb3ZlSXRlbSIsImNyZWF0ZUZhbGxiYWNrYWJsZUNhY2hlIiwiY2FjaGVzIiwiY3VycmVudCIsInNoaWZ0IiwiY3JlYXRlTnVsbENhY2hlIiwiY2F0Y2giLCJfa2V5IiwicmVzdWx0IiwiY3JlYXRlSW5NZW1vcnlDYWNoZSIsInNlcmlhbGl6YWJsZSIsImNhY2hlIiwicHJvbWlzZSIsImNyZWF0ZUF1dGgiLCJhdXRoTW9kZSIsImFwcElkIiwiYXBpS2V5IiwiY3JlZGVudGlhbHMiLCJoZWFkZXJzIiwiQXV0aE1vZGUiLCJXaXRoaW5IZWFkZXJzIiwicXVlcnlQYXJhbWV0ZXJzIiwiV2l0aGluUXVlcnlQYXJhbWV0ZXJzIiwic2h1ZmZsZSIsImFycmF5IiwiYyIsImxlbmd0aCIsImIiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJhIiwiYWRkTWV0aG9kcyIsImJhc2UiLCJtZXRob2RzIiwia2V5cyIsImZvckVhY2giLCJlbmNvZGUiLCJmb3JtYXQiLCJhcmdzIiwiaSIsInJlcGxhY2UiLCJlbmNvZGVVUklDb21wb25lbnQiLCJ2ZXJzaW9uIiwiY3JlYXRlTWFwcGVkUmVxdWVzdE9wdGlvbnMiLCJyZXF1ZXN0T3B0aW9ucyIsInRpbWVvdXQiLCJkYXRhIiwiaW5kZXhPZiIsImNhY2hlYWJsZSIsIkNhbGxFbnVtIiwiUmVhZCIsIldyaXRlIiwiQW55IiwiSG9zdFN0YXR1c0VudW0iLCJVcCIsIkRvd24iLCJUaW1lb3V0ZWQiLCJFWFBJUkFUSU9OX0RFTEFZIiwiY3JlYXRlU3RhdGVmdWxIb3N0IiwiaG9zdCIsInN0YXR1cyIsImxhc3RVcGRhdGUiLCJub3ciLCJpc1N0YXRlZnVsSG9zdFVwIiwiaXNTdGF0ZWZ1bEhvc3RUaW1lb3V0ZWQiLCJjcmVhdGVTdGF0ZWxlc3NIb3N0IiwicHJvdG9jb2wiLCJ1cmwiLCJhY2NlcHQiLCJNZXRob2RFbnVtIiwiRGVsZXRlIiwiR2V0IiwiUG9zdCIsIlB1dCIsImNyZWF0ZVJldHJ5YWJsZU9wdGlvbnMiLCJob3N0c0NhY2hlIiwic3RhdGVsZXNzSG9zdHMiLCJtYXAiLCJzdGF0ZWxlc3NIb3N0Iiwic3RhdGVmdWxIb3N0cyIsImhvc3RzVXAiLCJob3N0c1RpbWVvdXRlZCIsImhvc3RzQXZhaWxhYmxlIiwic3RhdGVsZXNzSG9zdHNBdmFpbGFibGUiLCJnZXRUaW1lb3V0IiwidGltZW91dHNDb3VudCIsImJhc2VUaW1lb3V0IiwidGltZW91dE11bHRpcGxpZXIiLCJpc05ldHdvcmtFcnJvciIsImlzVGltZWRPdXQiLCJpc1JldHJ5YWJsZSIsInJlc3BvbnNlIiwiaXNTdWNjZXNzIiwicmV0cnlEZWNpc2lvbiIsIm91dGNvbWVzIiwib25SZXRyeSIsIm9uU3VjY2VzcyIsIm9uRmFpbCIsInJldHJ5YWJsZVJlcXVlc3QiLCJ0cmFuc3BvcnRlciIsInJlcXVlc3QiLCJzdGFja1RyYWNlIiwic2VyaWFsaXplRGF0YSIsInNlcmlhbGl6ZUhlYWRlcnMiLCJtZXRob2QiLCJkYXRhUXVlcnlQYXJhbWV0ZXJzIiwidXNlckFnZW50IiwicmV0cnkiLCJob3N0cyIsInBvcCIsImNyZWF0ZVJldHJ5RXJyb3IiLCJzdGFja1RyYWNlV2l0aG91dENyZWRlbnRpYWxzIiwicGF5bG9hZCIsInNlcmlhbGl6ZVVybCIsInBhdGgiLCJjb25uZWN0VGltZW91dCIsInRpbWVvdXRzIiwiY29ubmVjdCIsInJlc3BvbnNlVGltZW91dCIsInB1c2hUb1N0YWNrVHJhY2UiLCJzdGFja0ZyYW1lIiwidHJpZXNMZWZ0IiwicHVzaCIsImRlY2lzaW9ucyIsImRlc2VyaWFsaXplU3VjY2VzcyIsImxvZ2dlciIsImluZm8iLCJzdGFja0ZyYW1lV2l0aG91dENyZWRlbnRpYWxzIiwiZGVzZXJpYWxpemVGYWlsdXJlIiwicmVxdWVzdGVyIiwic2VuZCIsInJldmVyc2UiLCJjcmVhdGVUcmFuc3BvcnRlciIsInJlcXVlc3RzQ2FjaGUiLCJyZXNwb25zZXNDYWNoZSIsInJlYWQiLCJtYXBwZWRSZXF1ZXN0T3B0aW9ucyIsImNyZWF0ZVJldHJ5YWJsZVJlcXVlc3QiLCJlcnIiLCJyZWplY3QiLCJfIiwid3JpdGUiLCJjcmVhdGVVc2VyQWdlbnQiLCJhZGQiLCJhZGRlZFVzZXJBZ2VudCIsInNlZ21lbnQiLCJjb250ZW50IiwiZSIsImNyZWF0ZURlc2VyaWFsaXphdGlvbkVycm9yIiwibWVzc2FnZSIsImNyZWF0ZUFwaUVycm9yIiwicXVlcnlQYXJhbWV0ZXJzQXNTdHJpbmciLCJzZXJpYWxpemVRdWVyeVBhcmFtZXRlcnMiLCJjaGFyQXQiLCJzdWJzdHIiLCJwYXJhbWV0ZXJzIiwiaXNPYmplY3RPckFycmF5IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiam9pbiIsIkFycmF5IiwiaXNBcnJheSIsInNlcmlhbGl6ZWRIZWFkZXJzIiwiaGVhZGVyIiwidG9Mb3dlckNhc2UiLCJtb2RpZmllZEhlYWRlcnMiLCJ0cmFuc3BvcnRlclN0YWNrVHJhY2UiLCJuYW1lIiwiY3JlYXRlU2VhcmNoQ2xpZW50IiwiYXV0aCIsImNvbmNhdCIsImFkZEFsZ29saWFBZ2VudCIsImNsZWFyQ2FjaGUiLCJjdXN0b21SZXF1ZXN0IiwiaW5pdEluZGV4IiwiaW5kZXhOYW1lIiwic2VhcmNoSW5kZXgiLCJtdWx0aXBsZVF1ZXJpZXMiLCJxdWVyaWVzIiwicmVxdWVzdHMiLCJxdWVyeSIsInBhcmFtcyIsIm11bHRpcGxlU2VhcmNoRm9yRmFjZXRWYWx1ZXMiLCJmYWNldE5hbWUiLCJmYWNldFF1ZXJ5Iiwic2VhcmNoRm9yRmFjZXRWYWx1ZXMiLCJmaW5kQW5zd2VycyIsInF1ZXJ5TGFuZ3VhZ2VzIiwic2VhcmNoIiwiTG9nTGV2ZWxFbnVtIiwiRGVidWciLCJJbmZvIiwiRXJyb3IiLCJjcmVhdGVDb25zb2xlTG9nZ2VyIiwibG9nTGV2ZWwiLCJkZWJ1ZyIsImNvbnNvbGUiLCJlcnJvciIsImNyZWF0ZUJyb3dzZXJYaHJSZXF1ZXN0ZXIiLCJiYXNlUmVxdWVzdGVyIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwic2V0UmVxdWVzdEhlYWRlciIsImNyZWF0ZVRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwiT1BFTkVEIiwiY2xlYXJUaW1lb3V0Iiwib25lcnJvciIsInJlc3BvbnNlVGV4dCIsIm9ubG9hZCIsImFsZ29saWFzZWFyY2giLCJjb21tb25PcHRpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/algoliasearch/dist/algoliasearch-lite.esm.browser.js\n");

/***/ })

};
;